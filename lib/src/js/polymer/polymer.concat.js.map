{
  "version": 3,
  "file": "polymer.concat.js",
  "sources": [
    "../polymer-gestures/src/scope.js",
    "../polymer-gestures/src/targetfind.js",
    "../polymer-gestures/src/touch-action.js",
    "../polymer-gestures/src/eventFactory.js",
    "../polymer-gestures/src/pointermap.js",
    "../polymer-gestures/src/dispatcher.js",
    "../polymer-gestures/src/mouse.js",
    "../polymer-gestures/src/touch.js",
    "../polymer-gestures/src/ms.js",
    "../polymer-gestures/src/pointer.js",
    "../polymer-gestures/src/platform-events.js",
    "../polymer-gestures/src/track.js",
    "../polymer-gestures/src/hold.js",
    "../polymer-gestures/src/tap.js",
    "../polymer-expressions/third_party/esprima/esprima.js",
    "../polymer-expressions/src/polymer-expressions.js",
    "build/polymer-versioned.js",
    "src/boot.js",
    "src/system/compat.js",
    "../HTMLImports/src/base.js",
    "src/system/module.js",
    "src/system/unresolved.js",
    "../observe-js/src/observe.js",
    "../NodeBind/src/NodeBind.js",
    "../TemplateBinding/src/TemplateBinding.js",
    "src/system/microtask.js",
    "src/system/patches-mdv.js",
    "src/lib/url.js",
    "src/lib/loader.js",
    "src/lib/styleloader.js",
    "src/lib/lang.js",
    "src/lib/job.js",
    "src/lib/dom.js",
    "src/lib/super.js",
    "src/lib/deserialize.js",
    "src/api.js",
    "src/instance/utils.js",
    "src/instance/events.js",
    "src/instance/attributes.js",
    "src/instance/properties.js",
    "src/instance/mdv.js",
    "src/instance/base.js",
    "src/instance/styles.js",
    "src/declaration/polymer.js",
    "src/declaration/path.js",
    "src/declaration/styles.js",
    "src/declaration/events.js",
    "src/declaration/properties.js",
    "src/declaration/attributes.js",
    "src/declaration/mdv.js",
    "src/declaration/prototype.js",
    "src/declaration/queue.js",
    "src/declaration/polymer-element.js",
    "src/lib/import.js",
    "src/lib/auto-binding.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACncA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjhCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uB;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9rDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACtVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACrwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AChPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACpPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;AC7PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A",
  "sourcesContent": [
    "/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nwindow.PolymerGestures = {};\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n  var HAS_FULL_PATH = false;\n\n  // test for full event path support\n  var pathTest = document.createElement('meta');\n  if (pathTest.createShadowRoot) {\n    var sr = pathTest.createShadowRoot();\n    var s = document.createElement('span');\n    sr.appendChild(s);\n    pathTest.addEventListener('testpath', function(ev) {\n      if (ev.path) {\n        // if the span is in the event path, then path[0] is the real source for all events\n        HAS_FULL_PATH = ev.path[0] === s;\n      }\n      ev.stopPropagation();\n    });\n    var ev = new CustomEvent('testpath', {bubbles: true});\n    // must add node to DOM to trigger event listener\n    document.head.appendChild(pathTest);\n    s.dispatchEvent(ev);\n    pathTest.parentNode.removeChild(pathTest);\n    sr = s = null;\n  }\n  pathTest = null;\n\n  var target = {\n    shadow: function(inEl) {\n      if (inEl) {\n        return inEl.shadowRoot || inEl.webkitShadowRoot;\n      }\n    },\n    canTarget: function(shadow) {\n      return shadow && Boolean(shadow.elementFromPoint);\n    },\n    targetingShadow: function(inEl) {\n      var s = this.shadow(inEl);\n      if (this.canTarget(s)) {\n        return s;\n      }\n    },\n    olderShadow: function(shadow) {\n      var os = shadow.olderShadowRoot;\n      if (!os) {\n        var se = shadow.querySelector('shadow');\n        if (se) {\n          os = se.olderShadowRoot;\n        }\n      }\n      return os;\n    },\n    allShadows: function(element) {\n      var shadows = [], s = this.shadow(element);\n      while(s) {\n        shadows.push(s);\n        s = this.olderShadow(s);\n      }\n      return shadows;\n    },\n    searchRoot: function(inRoot, x, y) {\n      var t, st, sr, os;\n      if (inRoot) {\n        t = inRoot.elementFromPoint(x, y);\n        if (t) {\n          // found element, check if it has a ShadowRoot\n          sr = this.targetingShadow(t);\n        } else if (inRoot !== document) {\n          // check for sibling roots\n          sr = this.olderShadow(inRoot);\n        }\n        // search other roots, fall back to light dom element\n        return this.searchRoot(sr, x, y) || t;\n      }\n    },\n    owner: function(element) {\n      if (!element) {\n        return document;\n      }\n      var s = element;\n      // walk up until you hit the shadow root or document\n      while (s.parentNode) {\n        s = s.parentNode;\n      }\n      // the owner element is expected to be a Document or ShadowRoot\n      if (s.nodeType != Node.DOCUMENT_NODE && s.nodeType != Node.DOCUMENT_FRAGMENT_NODE) {\n        s = document;\n      }\n      return s;\n    },\n    findTarget: function(inEvent) {\n      if (HAS_FULL_PATH && inEvent.path) {\n        return inEvent.path[0];\n      }\n      var x = inEvent.clientX, y = inEvent.clientY;\n      // if the listener is in the shadow root, it is much faster to start there\n      var s = this.owner(inEvent.target);\n      // if x, y is not in this root, fall back to document search\n      if (!s.elementFromPoint(x, y)) {\n        s = document;\n      }\n      return this.searchRoot(s, x, y);\n    },\n    findTouchAction: function(inEvent) {\n      var n;\n      if (HAS_FULL_PATH && inEvent.path) {\n        var path = inEvent.path;\n        for (var i = 0; i < path.length; i++) {\n          n = path[i];\n          if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {\n            return n.getAttribute('touch-action');\n          }\n        }\n      } else {\n        n = inEvent.target;\n        while(n) {\n          if (n.hasAttribute('touch-action')) {\n            return n.getAttribute('touch-action');\n          }\n          n = n.parentNode || n.host;\n        }\n      }\n      // auto is default\n      return \"auto\";\n    },\n    LCA: function(a, b) {\n      if (a === b) {\n        return a;\n      }\n      if (a && !b) {\n        return a;\n      }\n      if (b && !a) {\n        return b;\n      }\n      if (!b && !a) {\n        return document;\n      }\n      // fast case, a is a direct descendant of b or vice versa\n      if (a.contains && a.contains(b)) {\n        return a;\n      }\n      if (b.contains && b.contains(a)) {\n        return b;\n      }\n      var adepth = this.depth(a);\n      var bdepth = this.depth(b);\n      var d = adepth - bdepth;\n      if (d >= 0) {\n        a = this.walk(a, d);\n      } else {\n        b = this.walk(b, -d);\n      }\n      while (a && b && a !== b) {\n        a = a.parentNode || a.host;\n        b = b.parentNode || b.host;\n      }\n      return a;\n    },\n    walk: function(n, u) {\n      for (var i = 0; n && (i < u); i++) {\n        n = n.parentNode || n.host;\n      }\n      return n;\n    },\n    depth: function(n) {\n      var d = 0;\n      while(n) {\n        d++;\n        n = n.parentNode || n.host;\n      }\n      return d;\n    },\n    deepContains: function(a, b) {\n      var common = this.LCA(a, b);\n      // if a is the common ancestor, it must \"deeply\" contain b\n      return common === a;\n    },\n    insideNode: function(node, x, y) {\n      var rect = node.getBoundingClientRect();\n      return (rect.left <= x) && (x <= rect.right) && (rect.top <= y) && (y <= rect.bottom);\n    }\n  };\n  scope.targetFinding = target;\n  /**\n   * Given an event, finds the \"deepest\" node that could have been the original target before ShadowDOM retargetting\n   *\n   * @param {Event} Event An event object with clientX and clientY properties\n   * @return {Element} The probable event origninator\n   */\n  scope.findTarget = target.findTarget.bind(target);\n  /**\n   * Determines if the \"container\" node deeply contains the \"containee\" node, including situations where the \"containee\" is contained by one or more ShadowDOM\n   * roots.\n   *\n   * @param {Node} container\n   * @param {Node} containee\n   * @return {Boolean}\n   */\n  scope.deepContains = target.deepContains.bind(target);\n\n  /**\n   * Determines if the x/y position is inside the given node.\n   *\n   * Example:\n   *\n   *     function upHandler(event) {\n   *       var innode = PolymerGestures.insideNode(event.target, event.clientX, event.clientY);\n   *       if (innode) {\n   *         // wait for tap?\n   *       } else {\n   *         // tap will never happen\n   *       }\n   *     }\n   *\n   * @param {Node} node\n   * @param {Number} x Screen X position\n   * @param {Number} y screen Y position\n   * @return {Boolean}\n   */\n  scope.insideNode = target.insideNode;\n\n})(window.PolymerGestures);\n",
    "/*\n *\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function() {\n  function shadowSelector(v) {\n    return 'html /deep/ ' + selector(v);\n  }\n  function selector(v) {\n    return '[touch-action=\"' + v + '\"]';\n  }\n  function rule(v) {\n    return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + ';}';\n  }\n  var attrib2css = [\n    'none',\n    'auto',\n    'pan-x',\n    'pan-y',\n    {\n      rule: 'pan-x pan-y',\n      selectors: [\n        'pan-x pan-y',\n        'pan-y pan-x'\n      ]\n    },\n    'manipulation'\n  ];\n  var styles = '';\n  // only install stylesheet if the browser has touch action support\n  var hasTouchAction = typeof document.head.style.touchAction === 'string';\n  // only add shadow selectors if shadowdom is supported\n  var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;\n\n  if (hasTouchAction) {\n    attrib2css.forEach(function(r) {\n      if (String(r) === r) {\n        styles += selector(r) + rule(r) + '\\n';\n        if (hasShadowRoot) {\n          styles += shadowSelector(r) + rule(r) + '\\n';\n        }\n      } else {\n        styles += r.selectors.map(selector) + rule(r.rule) + '\\n';\n        if (hasShadowRoot) {\n          styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\\n';\n        }\n      }\n    });\n\n    var el = document.createElement('style');\n    el.textContent = styles;\n    document.head.appendChild(el);\n  }\n})();\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This is the constructor for new PointerEvents.\n *\n * New Pointer Events must be given a type, and an optional dictionary of\n * initialization properties.\n *\n * Due to certain platform requirements, events returned from the constructor\n * identify as MouseEvents.\n *\n * @constructor\n * @param {String} inType The type of the event to create.\n * @param {Object} [inDict] An optional dictionary of initial event properties.\n * @return {Event} A new PointerEvent of type `inType` and initialized with properties from `inDict`.\n */\n(function(scope) {\n\n  var MOUSE_PROPS = [\n    'bubbles',\n    'cancelable',\n    'view',\n    'detail',\n    'screenX',\n    'screenY',\n    'clientX',\n    'clientY',\n    'ctrlKey',\n    'altKey',\n    'shiftKey',\n    'metaKey',\n    'button',\n    'relatedTarget',\n    'pageX',\n    'pageY'\n  ];\n\n  var MOUSE_DEFAULTS = [\n    false,\n    false,\n    null,\n    null,\n    0,\n    0,\n    0,\n    0,\n    false,\n    false,\n    false,\n    false,\n    0,\n    null,\n    0,\n    0\n  ];\n\n  var NOP_FACTORY = function(){ return function(){}; };\n\n  var eventFactory = {\n    // TODO(dfreedm): this is overridden by tap recognizer, needs review\n    preventTap: NOP_FACTORY,\n    makeBaseEvent: function(inType, inDict) {\n      var e = document.createEvent('Event');\n      e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);\n      e.preventTap = eventFactory.preventTap(e);\n      return e;\n    },\n    makeGestureEvent: function(inType, inDict) {\n      inDict = inDict || Object.create(null);\n\n      var e = this.makeBaseEvent(inType, inDict);\n      for (var i = 0, keys = Object.keys(inDict), k; i < keys.length; i++) {\n        k = keys[i];\n        e[k] = inDict[k];\n      }\n      return e;\n    },\n    makePointerEvent: function(inType, inDict) {\n      inDict = inDict || Object.create(null);\n\n      var e = this.makeBaseEvent(inType, inDict);\n      // define inherited MouseEvent properties\n      for(var i = 0, p; i < MOUSE_PROPS.length; i++) {\n        p = MOUSE_PROPS[i];\n        e[p] = inDict[p] || MOUSE_DEFAULTS[i];\n      }\n      e.buttons = inDict.buttons || 0;\n\n      // Spec requires that pointers without pressure specified use 0.5 for down\n      // state and 0 for up state.\n      var pressure = 0;\n      if (inDict.pressure) {\n        pressure = inDict.pressure;\n      } else {\n        pressure = e.buttons ? 0.5 : 0;\n      }\n\n      // add x/y properties aliased to clientX/Y\n      e.x = e.clientX;\n      e.y = e.clientY;\n\n      // define the properties of the PointerEvent interface\n      e.pointerId = inDict.pointerId || 0;\n      e.width = inDict.width || 0;\n      e.height = inDict.height || 0;\n      e.pressure = pressure;\n      e.tiltX = inDict.tiltX || 0;\n      e.tiltY = inDict.tiltY || 0;\n      e.pointerType = inDict.pointerType || '';\n      e.hwTimestamp = inDict.hwTimestamp || 0;\n      e.isPrimary = inDict.isPrimary || false;\n      e._source = inDict._source || '';\n      return e;\n    }\n  };\n\n  scope.eventFactory = eventFactory;\n})(window.PolymerGestures);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This module implements an map of pointer states\n */\n(function(scope) {\n  var USE_MAP = window.Map && window.Map.prototype.forEach;\n  var POINTERS_FN = function(){ return this.size; };\n  function PointerMap() {\n    if (USE_MAP) {\n      var m = new Map();\n      m.pointers = POINTERS_FN;\n      return m;\n    } else {\n      this.keys = [];\n      this.values = [];\n    }\n  }\n\n  PointerMap.prototype = {\n    set: function(inId, inEvent) {\n      var i = this.keys.indexOf(inId);\n      if (i > -1) {\n        this.values[i] = inEvent;\n      } else {\n        this.keys.push(inId);\n        this.values.push(inEvent);\n      }\n    },\n    has: function(inId) {\n      return this.keys.indexOf(inId) > -1;\n    },\n    'delete': function(inId) {\n      var i = this.keys.indexOf(inId);\n      if (i > -1) {\n        this.keys.splice(i, 1);\n        this.values.splice(i, 1);\n      }\n    },\n    get: function(inId) {\n      var i = this.keys.indexOf(inId);\n      return this.values[i];\n    },\n    clear: function() {\n      this.keys.length = 0;\n      this.values.length = 0;\n    },\n    // return value, key, map\n    forEach: function(callback, thisArg) {\n      this.values.forEach(function(v, i) {\n        callback.call(thisArg, v, this.keys[i], this);\n      }, this);\n    },\n    pointers: function() {\n      return this.keys.length;\n    }\n  };\n\n  scope.PointerMap = PointerMap;\n})(window.PolymerGestures);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n  var CLONE_PROPS = [\n    // MouseEvent\n    'bubbles',\n    'cancelable',\n    'view',\n    'detail',\n    'screenX',\n    'screenY',\n    'clientX',\n    'clientY',\n    'ctrlKey',\n    'altKey',\n    'shiftKey',\n    'metaKey',\n    'button',\n    'relatedTarget',\n    // DOM Level 3\n    'buttons',\n    // PointerEvent\n    'pointerId',\n    'width',\n    'height',\n    'pressure',\n    'tiltX',\n    'tiltY',\n    'pointerType',\n    'hwTimestamp',\n    'isPrimary',\n    // event instance\n    'type',\n    'target',\n    'currentTarget',\n    'which',\n    'pageX',\n    'pageY',\n    'timeStamp',\n    // gesture addons\n    'preventTap',\n    'tapPrevented',\n    '_source'\n  ];\n\n  var CLONE_DEFAULTS = [\n    // MouseEvent\n    false,\n    false,\n    null,\n    null,\n    0,\n    0,\n    0,\n    0,\n    false,\n    false,\n    false,\n    false,\n    0,\n    null,\n    // DOM Level 3\n    0,\n    // PointerEvent\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    '',\n    0,\n    false,\n    // event instance\n    '',\n    null,\n    null,\n    0,\n    0,\n    0,\n    0,\n    function(){},\n    false\n  ];\n\n  var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');\n\n  var eventFactory = scope.eventFactory;\n\n  // set of recognizers to run for the currently handled event\n  var currentGestures;\n\n  /**\n   * This module is for normalizing events. Mouse and Touch events will be\n   * collected here, and fire PointerEvents that have the same semantics, no\n   * matter the source.\n   * Events fired:\n   *   - pointerdown: a pointing is added\n   *   - pointerup: a pointer is removed\n   *   - pointermove: a pointer is moved\n   *   - pointerover: a pointer crosses into an element\n   *   - pointerout: a pointer leaves an element\n   *   - pointercancel: a pointer will no longer generate events\n   */\n  var dispatcher = {\n    pointermap: new scope.PointerMap(),\n    requiredGestures: new scope.PointerMap(),\n    eventMap: Object.create(null),\n    // Scope objects for native events.\n    // This exists for ease of testing.\n    eventSources: Object.create(null),\n    eventSourceList: [],\n    gestures: [],\n    // map gesture event -> {listeners: int, index: gestures[int]}\n    dependencyMap: {\n      // make sure down and up are in the map to trigger \"register\"\n      down: {listeners: 0, index: -1},\n      up: {listeners: 0, index: -1}\n    },\n    gestureQueue: [],\n    /**\n     * Add a new event source that will generate pointer events.\n     *\n     * `inSource` must contain an array of event names named `events`, and\n     * functions with the names specified in the `events` array.\n     * @param {string} name A name for the event source\n     * @param {Object} source A new source of platform events.\n     */\n    registerSource: function(name, source) {\n      var s = source;\n      var newEvents = s.events;\n      if (newEvents) {\n        newEvents.forEach(function(e) {\n          if (s[e]) {\n            this.eventMap[e] = s[e].bind(s);\n          }\n        }, this);\n        this.eventSources[name] = s;\n        this.eventSourceList.push(s);\n      }\n    },\n    registerGesture: function(name, source) {\n      var obj = Object.create(null);\n      obj.listeners = 0;\n      obj.index = this.gestures.length;\n      for (var i = 0, g; i < source.exposes.length; i++) {\n        g = source.exposes[i].toLowerCase();\n        this.dependencyMap[g] = obj;\n      }\n      this.gestures.push(source);\n    },\n    register: function(element, initial) {\n      var l = this.eventSourceList.length;\n      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {\n        // call eventsource register\n        es.register.call(es, element, initial);\n      }\n    },\n    unregister: function(element) {\n      var l = this.eventSourceList.length;\n      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {\n        // call eventsource register\n        es.unregister.call(es, element);\n      }\n    },\n    // EVENTS\n    down: function(inEvent) {\n      this.requiredGestures.set(inEvent.pointerId, currentGestures);\n      this.fireEvent('down', inEvent);\n    },\n    move: function(inEvent) {\n      // pipe move events into gesture queue directly\n      inEvent.type = 'move';\n      this.fillGestureQueue(inEvent);\n    },\n    up: function(inEvent) {\n      this.fireEvent('up', inEvent);\n      this.requiredGestures.delete(inEvent.pointerId);\n    },\n    cancel: function(inEvent) {\n      inEvent.tapPrevented = true;\n      this.fireEvent('up', inEvent);\n      this.requiredGestures.delete(inEvent.pointerId);\n    },\n    // LISTENER LOGIC\n    eventHandler: function(inEvent) {\n      // This is used to prevent multiple dispatch of events from\n      // platform events. This can happen when two elements in different scopes\n      // are set up to create pointer events, which is relevant to Shadow DOM.\n\n      var type = inEvent.type;\n\n      // only generate the list of desired events on \"down\"\n      if (type === 'touchstart' || type === 'mousedown' || type === 'pointerdown' || type === 'MSPointerDown') {\n        if (!inEvent._handledByPG) {\n          currentGestures = {};\n        }\n        // map gesture names to ordered set of recognizers\n        var gesturesWanted = inEvent.currentTarget._pgEvents;\n        if (gesturesWanted) {\n          var gk = Object.keys(gesturesWanted);\n          for (var i = 0, r, ri, g; i < gk.length; i++) {\n            // gesture\n            g = gk[i];\n            if (gesturesWanted[g] > 0) {\n              // lookup gesture recognizer\n              r = this.dependencyMap[g];\n              // recognizer index\n              ri = r ? r.index : -1;\n              currentGestures[ri] = true;\n            }\n          }\n        }\n      }\n\n      if (inEvent._handledByPG) {\n        return;\n      }\n      var fn = this.eventMap && this.eventMap[type];\n      if (fn) {\n        fn(inEvent);\n      }\n      inEvent._handledByPG = true;\n    },\n    // set up event listeners\n    listen: function(target, events) {\n      for (var i = 0, l = events.length, e; (i < l) && (e = events[i]); i++) {\n        this.addEvent(target, e);\n      }\n    },\n    // remove event listeners\n    unlisten: function(target, events) {\n      for (var i = 0, l = events.length, e; (i < l) && (e = events[i]); i++) {\n        this.removeEvent(target, e);\n      }\n    },\n    addEvent: function(target, eventName) {\n      target.addEventListener(eventName, this.boundHandler);\n    },\n    removeEvent: function(target, eventName) {\n      target.removeEventListener(eventName, this.boundHandler);\n    },\n    // EVENT CREATION AND TRACKING\n    /**\n     * Creates a new Event of type `inType`, based on the information in\n     * `inEvent`.\n     *\n     * @param {string} inType A string representing the type of event to create\n     * @param {Event} inEvent A platform event with a target\n     * @return {Event} A PointerEvent of type `inType`\n     */\n    makeEvent: function(inType, inEvent) {\n      var e = eventFactory.makePointerEvent(inType, inEvent);\n      e.preventDefault = inEvent.preventDefault;\n      e.tapPrevented = inEvent.tapPrevented;\n      e._target = e._target || inEvent.target;\n      return e;\n    },\n    // make and dispatch an event in one call\n    fireEvent: function(inType, inEvent) {\n      var e = this.makeEvent(inType, inEvent);\n      return this.dispatchEvent(e);\n    },\n    /**\n     * Returns a snapshot of inEvent, with writable properties.\n     *\n     * @param {Event} inEvent An event that contains properties to copy.\n     * @return {Object} An object containing shallow copies of `inEvent`'s\n     *    properties.\n     */\n    cloneEvent: function(inEvent) {\n      var eventCopy = Object.create(null), p;\n      for (var i = 0; i < CLONE_PROPS.length; i++) {\n        p = CLONE_PROPS[i];\n        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];\n        // Work around SVGInstanceElement shadow tree\n        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.\n        // This is the behavior implemented by Firefox.\n        if (p === 'target' || p === 'relatedTarget') {\n          if (HAS_SVG_INSTANCE && eventCopy[p] instanceof SVGElementInstance) {\n            eventCopy[p] = eventCopy[p].correspondingUseElement;\n          }\n        }\n      }\n      // keep the semantics of preventDefault\n      eventCopy.preventDefault = function() {\n        inEvent.preventDefault();\n      };\n      return eventCopy;\n    },\n    /**\n     * Dispatches the event to its target.\n     *\n     * @param {Event} inEvent The event to be dispatched.\n     * @return {Boolean} True if an event handler returns true, false otherwise.\n     */\n    dispatchEvent: function(inEvent) {\n      var t = inEvent._target;\n      if (t) {\n        t.dispatchEvent(inEvent);\n        // clone the event for the gesture system to process\n        // clone after dispatch to pick up gesture prevention code\n        var clone = this.cloneEvent(inEvent);\n        clone.target = t;\n        this.fillGestureQueue(clone);\n      }\n    },\n    gestureTrigger: function() {\n      // process the gesture queue\n      for (var i = 0, e, rg; i < this.gestureQueue.length; i++) {\n        e = this.gestureQueue[i];\n        rg = e._requiredGestures;\n        for (var j = 0, g, fn; j < this.gestures.length; j++) {\n          // only run recognizer if an element in the source event's path is listening for those gestures\n          if (rg[j]) {\n            g = this.gestures[j];\n            fn = g[e.type];\n            if (fn) {\n              fn.call(g, e);\n            }\n          }\n        }\n      }\n      this.gestureQueue.length = 0;\n    },\n    fillGestureQueue: function(ev) {\n      // only trigger the gesture queue once\n      if (!this.gestureQueue.length) {\n        requestAnimationFrame(this.boundGestureTrigger);\n      }\n      ev._requiredGestures = this.requiredGestures.get(ev.pointerId);\n      this.gestureQueue.push(ev);\n    }\n  };\n  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);\n  dispatcher.boundGestureTrigger = dispatcher.gestureTrigger.bind(dispatcher);\n  scope.dispatcher = dispatcher;\n\n  /**\n   * Listen for `gesture` on `node` with the `handler` function\n   *\n   * If `handler` is the first listener for `gesture`, the underlying gesture recognizer is then enabled.\n   *\n   * @param {Element} node\n   * @param {string} gesture\n   * @return Boolean `gesture` is a valid gesture\n   */\n  scope.activateGesture = function(node, gesture) {\n    var g = gesture.toLowerCase();\n    var dep = dispatcher.dependencyMap[g];\n    if (dep) {\n      var recognizer = dispatcher.gestures[dep.index];\n      if (!node._pgListeners) {\n        dispatcher.register(node);\n        node._pgListeners = 0;\n      }\n      // TODO(dfreedm): re-evaluate bookkeeping to avoid using attributes\n      if (recognizer) {\n        var touchAction = recognizer.defaultActions && recognizer.defaultActions[g];\n        var actionNode;\n        switch(node.nodeType) {\n          case Node.ELEMENT_NODE:\n            actionNode = node;\n          break;\n          case Node.DOCUMENT_FRAGMENT_NODE:\n            actionNode = node.host;\n          break;\n          default:\n            actionNode = null;\n          break;\n        }\n        if (touchAction && actionNode && !actionNode.hasAttribute('touch-action')) {\n          actionNode.setAttribute('touch-action', touchAction);\n        }\n      }\n      if (!node._pgEvents) {\n        node._pgEvents = {};\n      }\n      node._pgEvents[g] = (node._pgEvents[g] || 0) + 1;\n      node._pgListeners++;\n    }\n    return Boolean(dep);\n  };\n\n  /**\n   *\n   * Listen for `gesture` from `node` with `handler` function.\n   *\n   * @param {Element} node\n   * @param {string} gesture\n   * @param {Function} handler\n   * @param {Boolean} capture\n   */\n  scope.addEventListener = function(node, gesture, handler, capture) {\n    if (handler) {\n      scope.activateGesture(node, gesture);\n      node.addEventListener(gesture, handler, capture);\n    }\n  };\n\n  /**\n   * Tears down the gesture configuration for `node`\n   *\n   * If `handler` is the last listener for `gesture`, the underlying gesture recognizer is disabled.\n   *\n   * @param {Element} node\n   * @param {string} gesture\n   * @return Boolean `gesture` is a valid gesture\n   */\n  scope.deactivateGesture = function(node, gesture) {\n    var g = gesture.toLowerCase();\n    var dep = dispatcher.dependencyMap[g];\n    if (dep) {\n      if (node._pgListeners > 0) {\n        node._pgListeners--;\n      }\n      if (node._pgListeners === 0) {\n        dispatcher.unregister(node);\n      }\n      if (node._pgEvents) {\n        if (node._pgEvents[g] > 0) {\n          node._pgEvents[g]--;\n        } else {\n          node._pgEvents[g] = 0;\n        }\n      }\n    }\n    return Boolean(dep);\n  };\n\n  /**\n   * Stop listening for `gesture` from `node` with `handler` function.\n   *\n   * @param {Element} node\n   * @param {string} gesture\n   * @param {Function} handler\n   * @param {Boolean} capture\n   */\n  scope.removeEventListener = function(node, gesture, handler, capture) {\n    if (handler) {\n      scope.deactivateGesture(node, gesture);\n      node.removeEventListener(gesture, handler, capture);\n    }\n  };\n})(window.PolymerGestures);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function (scope) {\n  var dispatcher = scope.dispatcher;\n  var pointermap = dispatcher.pointermap;\n  // radius around touchend that swallows mouse events\n  var DEDUP_DIST = 25;\n\n  var WHICH_TO_BUTTONS = [0, 1, 4, 2];\n\n  var HAS_BUTTONS = false;\n  try {\n    HAS_BUTTONS = new MouseEvent('test', {buttons: 1}).buttons === 1;\n  } catch (e) {}\n\n  // handler block for native mouse events\n  var mouseEvents = {\n    POINTER_ID: 1,\n    POINTER_TYPE: 'mouse',\n    events: [\n      'mousedown',\n      'mousemove',\n      'mouseup'\n    ],\n    exposes: [\n      'down',\n      'up',\n      'move'\n    ],\n    register: function(target) {\n      dispatcher.listen(target, this.events);\n    },\n    unregister: function(target) {\n      dispatcher.unlisten(target, this.events);\n    },\n    lastTouches: [],\n    // collide with the global mouse listener\n    isEventSimulatedFromTouch: function(inEvent) {\n      var lts = this.lastTouches;\n      var x = inEvent.clientX, y = inEvent.clientY;\n      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {\n        // simulated mouse events will be swallowed near a primary touchend\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {\n          return true;\n        }\n      }\n    },\n    prepareEvent: function(inEvent) {\n      var e = dispatcher.cloneEvent(inEvent);\n      e.pointerId = this.POINTER_ID;\n      e.isPrimary = true;\n      e.pointerType = this.POINTER_TYPE;\n      e._source = 'mouse';\n      if (!HAS_BUTTONS) {\n        e.buttons = WHICH_TO_BUTTONS[e.which] || 0;\n      }\n      return e;\n    },\n    mousedown: function(inEvent) {\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\n        var p = pointermap.has(this.POINTER_ID);\n        // TODO(dfreedman) workaround for some elements not sending mouseup\n        // http://crbug/149091\n        if (p) {\n          this.mouseup(inEvent);\n        }\n        var e = this.prepareEvent(inEvent);\n        e.target = scope.findTarget(inEvent);\n        pointermap.set(this.POINTER_ID, e.target);\n        dispatcher.down(e);\n      }\n    },\n    mousemove: function(inEvent) {\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\n        var target = pointermap.get(this.POINTER_ID);\n        if (target) {\n          var e = this.prepareEvent(inEvent);\n          e.target = target;\n          // handle case where we missed a mouseup\n          if (e.buttons === 0) {\n            dispatcher.cancel(e);\n            this.cleanupMouse();\n          } else {\n            dispatcher.move(e);\n          }\n        }\n      }\n    },\n    mouseup: function(inEvent) {\n      if (!this.isEventSimulatedFromTouch(inEvent)) {\n        var e = this.prepareEvent(inEvent);\n        e.relatedTarget = scope.findTarget(inEvent);\n        e.target = pointermap.get(this.POINTER_ID);\n        dispatcher.up(e);\n        this.cleanupMouse();\n      }\n    },\n    cleanupMouse: function() {\n      pointermap['delete'](this.POINTER_ID);\n    }\n  };\n\n  scope.mouseEvents = mouseEvents;\n})(window.PolymerGestures);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n  var dispatcher = scope.dispatcher;\n  var allShadows = scope.targetFinding.allShadows.bind(scope.targetFinding);\n  var pointermap = dispatcher.pointermap;\n  var touchMap = Array.prototype.map.call.bind(Array.prototype.map);\n  // This should be long enough to ignore compat mouse events made by touch\n  var DEDUP_TIMEOUT = 2500;\n  var CLICK_COUNT_TIMEOUT = 200;\n  var HYSTERESIS = 20;\n  var ATTRIB = 'touch-action';\n  // TODO(dfreedm): disable until http://crbug.com/399765 is resolved\n  // var HAS_TOUCH_ACTION = ATTRIB in document.head.style;\n  var HAS_TOUCH_ACTION = false;\n\n  // handler block for native touch events\n  var touchEvents = {\n    events: [\n      'touchstart',\n      'touchmove',\n      'touchend',\n      'touchcancel'\n    ],\n    exposes: [\n      'down',\n      'up',\n      'move'\n    ],\n    register: function(target, initial) {\n      if (initial) {\n        return;\n      }\n      dispatcher.listen(target, this.events);\n    },\n    unregister: function(target) {\n      dispatcher.unlisten(target, this.events);\n    },\n    scrollTypes: {\n      EMITTER: 'none',\n      XSCROLLER: 'pan-x',\n      YSCROLLER: 'pan-y',\n    },\n    touchActionToScrollType: function(touchAction) {\n      var t = touchAction;\n      var st = this.scrollTypes;\n      if (t === st.EMITTER) {\n        return 'none';\n      } else if (t === st.XSCROLLER) {\n        return 'X';\n      } else if (t === st.YSCROLLER) {\n        return 'Y';\n      } else {\n        return 'XY';\n      }\n    },\n    POINTER_TYPE: 'touch',\n    firstTouch: null,\n    isPrimaryTouch: function(inTouch) {\n      return this.firstTouch === inTouch.identifier;\n    },\n    setPrimaryTouch: function(inTouch) {\n      // set primary touch if there no pointers, or the only pointer is the mouse\n      if (pointermap.pointers() === 0 || (pointermap.pointers() === 1 && pointermap.has(1))) {\n        this.firstTouch = inTouch.identifier;\n        this.firstXY = {X: inTouch.clientX, Y: inTouch.clientY};\n        this.scrolling = null;\n        this.cancelResetClickCount();\n      }\n    },\n    removePrimaryPointer: function(inPointer) {\n      if (inPointer.isPrimary) {\n        this.firstTouch = null;\n        this.firstXY = null;\n        this.resetClickCount();\n      }\n    },\n    clickCount: 0,\n    resetId: null,\n    resetClickCount: function() {\n      var fn = function() {\n        this.clickCount = 0;\n        this.resetId = null;\n      }.bind(this);\n      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);\n    },\n    cancelResetClickCount: function() {\n      if (this.resetId) {\n        clearTimeout(this.resetId);\n      }\n    },\n    typeToButtons: function(type) {\n      var ret = 0;\n      if (type === 'touchstart' || type === 'touchmove') {\n        ret = 1;\n      }\n      return ret;\n    },\n    findTarget: function(touch, id) {\n      if (this.currentTouchEvent.type === 'touchstart') {\n        if (this.isPrimaryTouch(touch)) {\n          var fastPath = {\n            clientX: touch.clientX,\n            clientY: touch.clientY,\n            path: this.currentTouchEvent.path,\n            target: this.currentTouchEvent.target\n          };\n          return scope.findTarget(fastPath);\n        } else {\n          return scope.findTarget(touch);\n        }\n      }\n      // reuse target we found in touchstart\n      return pointermap.get(id);\n    },\n    touchToPointer: function(inTouch) {\n      var cte = this.currentTouchEvent;\n      var e = dispatcher.cloneEvent(inTouch);\n      // Spec specifies that pointerId 1 is reserved for Mouse.\n      // Touch identifiers can start at 0.\n      // Add 2 to the touch identifier for compatibility.\n      var id = e.pointerId = inTouch.identifier + 2;\n      e.target = this.findTarget(inTouch, id);\n      e.bubbles = true;\n      e.cancelable = true;\n      e.detail = this.clickCount;\n      e.buttons = this.typeToButtons(cte.type);\n      e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;\n      e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;\n      e.pressure = inTouch.webkitForce || inTouch.force || 0.5;\n      e.isPrimary = this.isPrimaryTouch(inTouch);\n      e.pointerType = this.POINTER_TYPE;\n      e._source = 'touch';\n      // forward touch preventDefaults\n      var self = this;\n      e.preventDefault = function() {\n        self.scrolling = false;\n        self.firstXY = null;\n        cte.preventDefault();\n      };\n      return e;\n    },\n    processTouches: function(inEvent, inFunction) {\n      var tl = inEvent.changedTouches;\n      this.currentTouchEvent = inEvent;\n      for (var i = 0, t, p; i < tl.length; i++) {\n        t = tl[i];\n        p = this.touchToPointer(t);\n        if (inEvent.type === 'touchstart') {\n          pointermap.set(p.pointerId, p.target);\n        }\n        if (pointermap.has(p.pointerId)) {\n          inFunction.call(this, p);\n        }\n        if (inEvent.type === 'touchend' || inEvent._cancel) {\n          this.cleanUpPointer(p);\n        }\n      }\n    },\n    // For single axis scrollers, determines whether the element should emit\n    // pointer events or behave as a scroller\n    shouldScroll: function(inEvent) {\n      if (this.firstXY) {\n        var ret;\n        var touchAction = scope.targetFinding.findTouchAction(inEvent);\n        var scrollAxis = this.touchActionToScrollType(touchAction);\n        if (scrollAxis === 'none') {\n          // this element is a touch-action: none, should never scroll\n          ret = false;\n        } else if (scrollAxis === 'XY') {\n          // this element should always scroll\n          ret = true;\n        } else {\n          var t = inEvent.changedTouches[0];\n          // check the intended scroll axis, and other axis\n          var a = scrollAxis;\n          var oa = scrollAxis === 'Y' ? 'X' : 'Y';\n          var da = Math.abs(t['client' + a] - this.firstXY[a]);\n          var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);\n          // if delta in the scroll axis > delta other axis, scroll instead of\n          // making events\n          ret = da >= doa;\n        }\n        return ret;\n      }\n    },\n    findTouch: function(inTL, inId) {\n      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {\n        if (t.identifier === inId) {\n          return true;\n        }\n      }\n    },\n    // In some instances, a touchstart can happen without a touchend. This\n    // leaves the pointermap in a broken state.\n    // Therefore, on every touchstart, we remove the touches that did not fire a\n    // touchend event.\n    // To keep state globally consistent, we fire a\n    // pointercancel for this \"abandoned\" touch\n    vacuumTouches: function(inEvent) {\n      var tl = inEvent.touches;\n      // pointermap.pointers() should be < tl.length here, as the touchstart has not\n      // been processed yet.\n      if (pointermap.pointers() >= tl.length) {\n        var d = [];\n        pointermap.forEach(function(value, key) {\n          // Never remove pointerId == 1, which is mouse.\n          // Touch identifiers are 2 smaller than their pointerId, which is the\n          // index in pointermap.\n          if (key !== 1 && !this.findTouch(tl, key - 2)) {\n            var p = value;\n            d.push(p);\n          }\n        }, this);\n        d.forEach(function(p) {\n          this.cancel(p);\n          pointermap.delete(p.pointerId);\n        });\n      }\n    },\n    touchstart: function(inEvent) {\n      this.vacuumTouches(inEvent);\n      this.setPrimaryTouch(inEvent.changedTouches[0]);\n      this.dedupSynthMouse(inEvent);\n      if (!this.scrolling) {\n        this.clickCount++;\n        this.processTouches(inEvent, this.down);\n      }\n    },\n    down: function(inPointer) {\n      dispatcher.down(inPointer);\n    },\n    touchmove: function(inEvent) {\n      if (HAS_TOUCH_ACTION) {\n        // touchevent.cancelable == false is sent when the page is scrolling under native Touch Action in Chrome 36\n        // https://groups.google.com/a/chromium.org/d/msg/input-dev/wHnyukcYBcA/b9kmtwM1jJQJ\n        if (inEvent.cancelable) {\n          this.processTouches(inEvent, this.move);\n        }\n      } else {\n        if (!this.scrolling) {\n          if (this.scrolling === null && this.shouldScroll(inEvent)) {\n            this.scrolling = true;\n          } else {\n            this.scrolling = false;\n            inEvent.preventDefault();\n            this.processTouches(inEvent, this.move);\n          }\n        } else if (this.firstXY) {\n          var t = inEvent.changedTouches[0];\n          var dx = t.clientX - this.firstXY.X;\n          var dy = t.clientY - this.firstXY.Y;\n          var dd = Math.sqrt(dx * dx + dy * dy);\n          if (dd >= HYSTERESIS) {\n            this.touchcancel(inEvent);\n            this.scrolling = true;\n            this.firstXY = null;\n          }\n        }\n      }\n    },\n    move: function(inPointer) {\n      dispatcher.move(inPointer);\n    },\n    touchend: function(inEvent) {\n      this.dedupSynthMouse(inEvent);\n      this.processTouches(inEvent, this.up);\n    },\n    up: function(inPointer) {\n      inPointer.relatedTarget = scope.findTarget(inPointer);\n      dispatcher.up(inPointer);\n    },\n    cancel: function(inPointer) {\n      dispatcher.cancel(inPointer);\n    },\n    touchcancel: function(inEvent) {\n      inEvent._cancel = true;\n      this.processTouches(inEvent, this.cancel);\n    },\n    cleanUpPointer: function(inPointer) {\n      pointermap['delete'](inPointer.pointerId);\n      this.removePrimaryPointer(inPointer);\n    },\n    // prevent synth mouse events from creating pointer events\n    dedupSynthMouse: function(inEvent) {\n      var lts = scope.mouseEvents.lastTouches;\n      var t = inEvent.changedTouches[0];\n      // only the primary finger will synth mouse events\n      if (this.isPrimaryTouch(t)) {\n        // remember x/y of last touch\n        var lt = {x: t.clientX, y: t.clientY};\n        lts.push(lt);\n        var fn = (function(lts, lt){\n          var i = lts.indexOf(lt);\n          if (i > -1) {\n            lts.splice(i, 1);\n          }\n        }).bind(null, lts, lt);\n        setTimeout(fn, DEDUP_TIMEOUT);\n      }\n    }\n  };\n\n  scope.touchEvents = touchEvents;\n})(window.PolymerGestures);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n  var dispatcher = scope.dispatcher;\n  var pointermap = dispatcher.pointermap;\n  var HAS_BITMAP_TYPE = window.MSPointerEvent && typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';\n  var msEvents = {\n    events: [\n      'MSPointerDown',\n      'MSPointerMove',\n      'MSPointerUp',\n      'MSPointerCancel',\n    ],\n    register: function(target) {\n      dispatcher.listen(target, this.events);\n    },\n    unregister: function(target) {\n      dispatcher.unlisten(target, this.events);\n    },\n    POINTER_TYPES: [\n      '',\n      'unavailable',\n      'touch',\n      'pen',\n      'mouse'\n    ],\n    prepareEvent: function(inEvent) {\n      var e = inEvent;\n      e = dispatcher.cloneEvent(inEvent);\n      if (HAS_BITMAP_TYPE) {\n        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];\n      }\n      e._source = 'ms';\n      return e;\n    },\n    cleanup: function(id) {\n      pointermap['delete'](id);\n    },\n    MSPointerDown: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      e.target = scope.findTarget(inEvent);\n      pointermap.set(inEvent.pointerId, e.target);\n      dispatcher.down(e);\n    },\n    MSPointerMove: function(inEvent) {\n      var target = pointermap.get(inEvent.pointerId);\n      if (target) {\n        var e = this.prepareEvent(inEvent);\n        e.target = target;\n        dispatcher.move(e);\n      }\n    },\n    MSPointerUp: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      e.relatedTarget = scope.findTarget(inEvent);\n      e.target = pointermap.get(e.pointerId);\n      dispatcher.up(e);\n      this.cleanup(inEvent.pointerId);\n    },\n    MSPointerCancel: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      e.relatedTarget = scope.findTarget(inEvent);\n      e.target = pointermap.get(e.pointerId);\n      dispatcher.cancel(e);\n      this.cleanup(inEvent.pointerId);\n    }\n  };\n\n  scope.msEvents = msEvents;\n})(window.PolymerGestures);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n  var dispatcher = scope.dispatcher;\n  var pointermap = dispatcher.pointermap;\n  var pointerEvents = {\n    events: [\n      'pointerdown',\n      'pointermove',\n      'pointerup',\n      'pointercancel'\n    ],\n    prepareEvent: function(inEvent) {\n      var e = dispatcher.cloneEvent(inEvent);\n      e._source = 'pointer';\n      return e;\n    },\n    register: function(target) {\n      dispatcher.listen(target, this.events);\n    },\n    unregister: function(target) {\n      dispatcher.unlisten(target, this.events);\n    },\n    cleanup: function(id) {\n      pointermap['delete'](id);\n    },\n    pointerdown: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      e.target = scope.findTarget(inEvent);\n      pointermap.set(e.pointerId, e.target);\n      dispatcher.down(e);\n    },\n    pointermove: function(inEvent) {\n      var target = pointermap.get(inEvent.pointerId);\n      if (target) {\n        var e = this.prepareEvent(inEvent);\n        e.target = target;\n        dispatcher.move(e);\n      }\n    },\n    pointerup: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      e.relatedTarget = scope.findTarget(inEvent);\n      e.target = pointermap.get(e.pointerId);\n      dispatcher.up(e);\n      this.cleanup(inEvent.pointerId);\n    },\n    pointercancel: function(inEvent) {\n      var e = this.prepareEvent(inEvent);\n      e.relatedTarget = scope.findTarget(inEvent);\n      e.target = pointermap.get(e.pointerId);\n      dispatcher.cancel(e);\n      this.cleanup(inEvent.pointerId);\n    }\n  };\n\n  scope.pointerEvents = pointerEvents;\n})(window.PolymerGestures);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This module contains the handlers for native platform events.\n * From here, the dispatcher is called to create unified pointer events.\n * Included are touch events (v1), mouse events, and MSPointerEvents.\n */\n(function(scope) {\n  var dispatcher = scope.dispatcher;\n  var nav = window.navigator;\n\n  if (window.PointerEvent) {\n    dispatcher.registerSource('pointer', scope.pointerEvents);\n  } else if (nav.msPointerEnabled) {\n    dispatcher.registerSource('ms', scope.msEvents);\n  } else {\n    dispatcher.registerSource('mouse', scope.mouseEvents);\n    if (window.ontouchstart !== undefined) {\n      dispatcher.registerSource('touch', scope.touchEvents);\n      /*\n       * NOTE: an empty touch listener on body will reactivate nodes imported from templates with touch listeners\n       * Removing it will re-break the nodes\n       *\n       * Work around for https://bugs.webkit.org/show_bug.cgi?id=135628\n       */\n      var isSafari = nav.userAgent.match('Safari') && !nav.userAgent.match('Chrome');\n      if (isSafari) {\n        document.body.addEventListener('touchstart', function(){});\n      }\n    }\n  }\n  dispatcher.register(document, true);\n})(window.PolymerGestures);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This event denotes the beginning of a series of tracking events.\n *\n * @module PointerGestures\n * @submodule Events\n * @class trackstart\n */\n/**\n * Pixels moved in the x direction since trackstart.\n * @type Number\n * @property dx\n */\n/**\n * Pixes moved in the y direction since trackstart.\n * @type Number\n * @property dy\n */\n/**\n * Pixels moved in the x direction since the last track.\n * @type Number\n * @property ddx\n */\n/**\n * Pixles moved in the y direction since the last track.\n * @type Number\n * @property ddy\n */\n/**\n * The clientX position of the track gesture.\n * @type Number\n * @property clientX\n */\n/**\n * The clientY position of the track gesture.\n * @type Number\n * @property clientY\n */\n/**\n * The pageX position of the track gesture.\n * @type Number\n * @property pageX\n */\n/**\n * The pageY position of the track gesture.\n * @type Number\n * @property pageY\n */\n/**\n * The screenX position of the track gesture.\n * @type Number\n * @property screenX\n */\n/**\n * The screenY position of the track gesture.\n * @type Number\n * @property screenY\n */\n/**\n * The last x axis direction of the pointer.\n * @type Number\n * @property xDirection\n */\n/**\n * The last y axis direction of the pointer.\n * @type Number\n * @property yDirection\n */\n/**\n * A shared object between all tracking events.\n * @type Object\n * @property trackInfo\n */\n/**\n * The element currently under the pointer.\n * @type Element\n * @property relatedTarget\n */\n/**\n * The type of pointer that make the track gesture.\n * @type String\n * @property pointerType\n */\n/**\n *\n * This event fires for all pointer movement being tracked.\n *\n * @class track\n * @extends trackstart\n */\n/**\n * This event fires when the pointer is no longer being tracked.\n *\n * @class trackend\n * @extends trackstart\n */\n\n (function(scope) {\n   var dispatcher = scope.dispatcher;\n   var eventFactory = scope.eventFactory;\n   var pointermap = new scope.PointerMap();\n   var track = {\n     events: [\n       'down',\n       'move',\n       'up',\n     ],\n     exposes: [\n      'trackstart',\n      'track',\n      'trackx',\n      'tracky',\n      'trackend'\n     ],\n     defaultActions: {\n       'track': 'none',\n       'trackx': 'pan-y',\n       'tracky': 'pan-x'\n     },\n     WIGGLE_THRESHOLD: 4,\n     clampDir: function(inDelta) {\n       return inDelta > 0 ? 1 : -1;\n     },\n     calcPositionDelta: function(inA, inB) {\n       var x = 0, y = 0;\n       if (inA && inB) {\n         x = inB.pageX - inA.pageX;\n         y = inB.pageY - inA.pageY;\n       }\n       return {x: x, y: y};\n     },\n     fireTrack: function(inType, inEvent, inTrackingData) {\n       var t = inTrackingData;\n       var d = this.calcPositionDelta(t.downEvent, inEvent);\n       var dd = this.calcPositionDelta(t.lastMoveEvent, inEvent);\n       if (dd.x) {\n         t.xDirection = this.clampDir(dd.x);\n       } else if (inType === 'trackx') {\n         return;\n       }\n       if (dd.y) {\n         t.yDirection = this.clampDir(dd.y);\n       } else if (inType === 'tracky') {\n         return;\n       }\n       var gestureProto = {\n         bubbles: true,\n         cancelable: true,\n         trackInfo: t.trackInfo,\n         relatedTarget: inEvent.relatedTarget,\n         pointerType: inEvent.pointerType,\n         pointerId: inEvent.pointerId,\n         _source: 'track'\n       };\n       if (inType !== 'tracky') {\n         gestureProto.x = inEvent.x;\n         gestureProto.dx = d.x;\n         gestureProto.ddx = dd.x;\n         gestureProto.clientX = inEvent.clientX;\n         gestureProto.pageX = inEvent.pageX;\n         gestureProto.screenX = inEvent.screenX;\n         gestureProto.xDirection = t.xDirection;\n       }\n       if (inType !== 'trackx') {\n         gestureProto.dy = d.y;\n         gestureProto.ddy = dd.y;\n         gestureProto.y = inEvent.y;\n         gestureProto.clientY = inEvent.clientY;\n         gestureProto.pageY = inEvent.pageY;\n         gestureProto.screenY = inEvent.screenY;\n         gestureProto.yDirection = t.yDirection;\n       }\n       var e = eventFactory.makeGestureEvent(inType, gestureProto);\n       t.downTarget.dispatchEvent(e);\n     },\n     down: function(inEvent) {\n       if (inEvent.isPrimary && (inEvent.pointerType === 'mouse' ? inEvent.buttons === 1 : true)) {\n         var p = {\n           downEvent: inEvent,\n           downTarget: inEvent.target,\n           trackInfo: {},\n           lastMoveEvent: null,\n           xDirection: 0,\n           yDirection: 0,\n           tracking: false\n         };\n         pointermap.set(inEvent.pointerId, p);\n       }\n     },\n     move: function(inEvent) {\n       var p = pointermap.get(inEvent.pointerId);\n       if (p) {\n         if (!p.tracking) {\n           var d = this.calcPositionDelta(p.downEvent, inEvent);\n           var move = d.x * d.x + d.y * d.y;\n           // start tracking only if finger moves more than WIGGLE_THRESHOLD\n           if (move > this.WIGGLE_THRESHOLD) {\n             p.tracking = true;\n             p.lastMoveEvent = p.downEvent;\n             this.fireTrack('trackstart', inEvent, p);\n           }\n         }\n         if (p.tracking) {\n           this.fireTrack('track', inEvent, p);\n           this.fireTrack('trackx', inEvent, p);\n           this.fireTrack('tracky', inEvent, p);\n         }\n         p.lastMoveEvent = inEvent;\n       }\n     },\n     up: function(inEvent) {\n       var p = pointermap.get(inEvent.pointerId);\n       if (p) {\n         if (p.tracking) {\n           this.fireTrack('trackend', inEvent, p);\n         }\n         pointermap.delete(inEvent.pointerId);\n       }\n     }\n   };\n   dispatcher.registerGesture('track', track);\n })(window.PolymerGestures);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This event is fired when a pointer is held down for 200ms.\n *\n * @module PointerGestures\n * @submodule Events\n * @class hold\n */\n/**\n * Type of pointer that made the holding event.\n * @type String\n * @property pointerType\n */\n/**\n * Screen X axis position of the held pointer\n * @type Number\n * @property clientX\n */\n/**\n * Screen Y axis position of the held pointer\n * @type Number\n * @property clientY\n */\n/**\n * Type of pointer that made the holding event.\n * @type String\n * @property pointerType\n */\n/**\n * This event is fired every 200ms while a pointer is held down.\n *\n * @class holdpulse\n * @extends hold\n */\n/**\n * Milliseconds pointer has been held down.\n * @type Number\n * @property holdTime\n */\n/**\n * This event is fired when a held pointer is released or moved.\n *\n * @class release\n */\n\n(function(scope) {\n  var dispatcher = scope.dispatcher;\n  var eventFactory = scope.eventFactory;\n  var hold = {\n    // wait at least HOLD_DELAY ms between hold and pulse events\n    HOLD_DELAY: 200,\n    // pointer can move WIGGLE_THRESHOLD pixels before not counting as a hold\n    WIGGLE_THRESHOLD: 16,\n    events: [\n      'down',\n      'move',\n      'up',\n    ],\n    exposes: [\n      'hold',\n      'holdpulse',\n      'release'\n    ],\n    heldPointer: null,\n    holdJob: null,\n    pulse: function() {\n      var hold = Date.now() - this.heldPointer.timeStamp;\n      var type = this.held ? 'holdpulse' : 'hold';\n      this.fireHold(type, hold);\n      this.held = true;\n    },\n    cancel: function() {\n      clearInterval(this.holdJob);\n      if (this.held) {\n        this.fireHold('release');\n      }\n      this.held = false;\n      this.heldPointer = null;\n      this.target = null;\n      this.holdJob = null;\n    },\n    down: function(inEvent) {\n      if (inEvent.isPrimary && !this.heldPointer) {\n        this.heldPointer = inEvent;\n        this.target = inEvent.target;\n        this.holdJob = setInterval(this.pulse.bind(this), this.HOLD_DELAY);\n      }\n    },\n    up: function(inEvent) {\n      if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {\n        this.cancel();\n      }\n    },\n    move: function(inEvent) {\n      if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {\n        var x = inEvent.clientX - this.heldPointer.clientX;\n        var y = inEvent.clientY - this.heldPointer.clientY;\n        if ((x * x + y * y) > this.WIGGLE_THRESHOLD) {\n          this.cancel();\n        }\n      }\n    },\n    fireHold: function(inType, inHoldTime) {\n      var p = {\n        bubbles: true,\n        cancelable: true,\n        pointerType: this.heldPointer.pointerType,\n        pointerId: this.heldPointer.pointerId,\n        x: this.heldPointer.clientX,\n        y: this.heldPointer.clientY,\n        _source: 'hold'\n      };\n      if (inHoldTime) {\n        p.holdTime = inHoldTime;\n      }\n      var e = eventFactory.makeGestureEvent(inType, p);\n      this.target.dispatchEvent(e);\n    }\n  };\n  dispatcher.registerGesture('hold', hold);\n})(window.PolymerGestures);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This event is fired when a pointer quickly goes down and up, and is used to\n * denote activation.\n *\n * Any gesture event can prevent the tap event from being created by calling\n * `event.preventTap`.\n *\n * Any pointer event can prevent the tap by setting the `tapPrevented` property\n * on itself.\n *\n * @module PointerGestures\n * @submodule Events\n * @class tap\n */\n/**\n * X axis position of the tap.\n * @property x\n * @type Number\n */\n/**\n * Y axis position of the tap.\n * @property y\n * @type Number\n */\n/**\n * Type of the pointer that made the tap.\n * @property pointerType\n * @type String\n */\n(function(scope) {\n  var dispatcher = scope.dispatcher;\n  var eventFactory = scope.eventFactory;\n  var pointermap = new scope.PointerMap();\n  var tap = {\n    events: [\n      'down',\n      'up'\n    ],\n    exposes: [\n      'tap'\n    ],\n    down: function(inEvent) {\n      if (inEvent.isPrimary && !inEvent.tapPrevented) {\n        pointermap.set(inEvent.pointerId, {\n          target: inEvent.target,\n          buttons: inEvent.buttons,\n          x: inEvent.clientX,\n          y: inEvent.clientY\n        });\n      }\n    },\n    shouldTap: function(e, downState) {\n      if (e.pointerType === 'mouse') {\n        // only allow left click to tap for mouse\n        return downState.buttons === 1;\n      }\n      return !e.tapPrevented;\n    },\n    up: function(inEvent) {\n      var start = pointermap.get(inEvent.pointerId);\n      if (start && this.shouldTap(inEvent, start)) {\n        // up.relatedTarget is target currently under finger\n        var t = scope.targetFinding.LCA(start.target, inEvent.relatedTarget);\n        if (t) {\n          var e = eventFactory.makeGestureEvent('tap', {\n            bubbles: true,\n            cancelable: true,\n            x: inEvent.clientX,\n            y: inEvent.clientY,\n            detail: inEvent.detail,\n            pointerType: inEvent.pointerType,\n            pointerId: inEvent.pointerId,\n            altKey: inEvent.altKey,\n            ctrlKey: inEvent.ctrlKey,\n            metaKey: inEvent.metaKey,\n            shiftKey: inEvent.shiftKey,\n            _source: 'tap'\n          });\n          t.dispatchEvent(e);\n        }\n      }\n      pointermap.delete(inEvent.pointerId);\n    }\n  };\n  // patch eventFactory to remove id from tap's pointermap for preventTap calls\n  eventFactory.preventTap = function(e) {\n    return function() {\n      e.tapPrevented = true;\n      pointermap.delete(e.pointerId);\n    };\n  };\n  dispatcher.registerGesture('tap', tap);\n})(window.PolymerGestures);\n",
    "/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (global) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        Syntax,\n        Messages,\n        source,\n        index,\n        length,\n        delegate,\n        lookahead,\n        state;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n\n    Syntax = {\n        ArrayExpression: 'ArrayExpression',\n        BinaryExpression: 'BinaryExpression',\n        CallExpression: 'CallExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        Identifier: 'Identifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ThisExpression: 'ThisExpression',\n        UnaryExpression: 'UnaryExpression'\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared'\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 32) ||  // space\n            (ch === 9) ||      // tab\n            (ch === 0xB) ||\n            (ch === 0xC) ||\n            (ch === 0xA0) ||\n            (ch >= 0x1680 && '\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122);          // a..z\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)\n            (ch >= 65 && ch <= 90) ||         // A..Z\n            (ch >= 97 && ch <= 122) ||        // a..z\n            (ch >= 48 && ch <= 57);           // 0..9\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        return (id === 'this')\n    }\n\n    // 7.4 Comments\n\n    function skipWhitespace() {\n        while (index < length && isWhiteSpace(source.charCodeAt(index))) {\n           ++index;\n        }\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        id = getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            range: [start, index]\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2;\n\n        switch (code) {\n\n        // Check for most common single-character punctuators.\n        case 46:   // . dot\n        case 40:   // ( open bracket\n        case 41:   // ) close bracket\n        case 59:   // ; semicolon\n        case 44:   // , comma\n        case 123:  // { open curly brace\n        case 125:  // } close curly brace\n        case 91:   // [\n        case 93:   // ]\n        case 58:   // :\n        case 63:   // ?\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                range: [start, index]\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (char #61) marks an assignment or comparison operator.\n            if (code2 === 61) {\n                switch (code) {\n                case 37:  // %\n                case 38:  // &\n                case 42:  // *:\n                case 43:  // +\n                case 45:  // -\n                case 47:  // /\n                case 60:  // <\n                case 62:  // >\n                case 124: // |\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        range: [start, index]\n                    };\n\n                case 33: // !\n                case 61: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 61) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        range: [start, index]\n                    };\n                default:\n                    break;\n                }\n            }\n            break;\n        }\n\n        // Peek more characters.\n\n        ch2 = source[index + 1];\n\n        // Other 2-character punctuators: && ||\n\n        if (ch1 === ch2 && ('&|'.indexOf(ch1) >= 0)) {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch1 + ch2,\n                range: [start, index]\n            };\n        }\n\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                range: [start, index]\n            };\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // 7.8.3 Numeric Literals\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            if (number === '0') {\n                // decimal number starts with '0' such as '09' is illegal.\n                if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        str += ch;\n                        break;\n                    }\n                } else {\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            range: [start, index]\n        };\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advance() {\n        var ch;\n\n        skipWhitespace();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                range: [index, index]\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        // Very common: ( and ) and ;\n        if (ch === 40 || ch === 41 || ch === 58) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (#39) or double quote (#34).\n        if (ch === 39 || ch === 34) {\n            return scanStringLiteral();\n        }\n\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Dot (.) char #46 can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 46) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        return scanPunctuator();\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.range[1];\n\n        lookahead = advance();\n\n        index = token.range[1];\n\n        return token;\n    }\n\n    function peek() {\n        var pos;\n\n        pos = index;\n        lookahead = advance();\n        index = pos;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    assert(index < args.length, 'Message reference must be in range');\n                    return args[index];\n                }\n            );\n\n        error = new Error(msg);\n        error.index = index;\n        error.description = msg;\n        throw error;\n    }\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    function consumeSemicolon() {\n        // Catch the very common case first: immediately a semicolon (char #59).\n        if (source.charCodeAt(index) === 59) {\n            lex();\n            return;\n        }\n\n        skipWhitespace();\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [];\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        expect(']');\n\n        return delegate.createArrayExpression(elements);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parseObjectPropertyKey() {\n        var token;\n\n        skipWhitespace();\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            return delegate.createLiteral(token);\n        }\n\n        return delegate.createIdentifier(token.value);\n    }\n\n    function parseObjectProperty() {\n        var token, key;\n\n        token = lookahead;\n        skipWhitespace();\n\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpected(token);\n        }\n\n        key = parseObjectPropertyKey();\n        expect(':');\n        return delegate.createProperty('init', key, parseExpression());\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [];\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parseObjectProperty());\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return delegate.createObjectExpression(properties);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr;\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        type = lookahead.type;\n\n        if (type === Token.Identifier) {\n            expr = delegate.createIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            expr = delegate.createLiteral(lex());\n        } else if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                lex();\n                expr = delegate.createThisExpression();\n            }\n        } else if (type === Token.BooleanLiteral) {\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = delegate.createLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            token = lex();\n            token.value = null;\n            expr = delegate.createLiteral(token);\n        } else if (match('[')) {\n            expr = parseArrayInitialiser();\n        } else if (match('{')) {\n            expr = parseObjectInitialiser();\n        }\n\n        if (expr) {\n            return expr;\n        }\n\n        throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseExpression());\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token;\n\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return delegate.createIdentifier(token.value);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var expr, args, property;\n\n        expr = parsePrimaryExpression();\n\n        while (true) {\n            if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else if (match('.')) {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            } else if (match('(')) {\n                args = parseArguments();\n                expr = delegate.createCallExpression(expr, args);\n            } else {\n                break;\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    var parsePostfixExpression = parseLeftHandSideExpression;\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('+') || match('-') || match('!')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            throwError({}, Messages.UnexpectedToken);\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return expr;\n    }\n\n    function binaryPrecedence(token) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = 7;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var expr, token, prec, stack, right, operator, left, i;\n\n        left = parseUnaryExpression();\n\n        token = lookahead;\n        prec = binaryPrecedence(token);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                expr = delegate.createBinaryExpression(operator, left, right);\n                stack.push(expr);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, consequent, alternate;\n\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            consequent = parseConditionalExpression();\n            expect(':');\n            alternate = parseConditionalExpression();\n\n            expr = delegate.createConditionalExpression(expr, consequent, alternate);\n        }\n\n        return expr;\n    }\n\n    // Simplification since we do not support AssignmentExpression.\n    var parseExpression = parseConditionalExpression;\n\n    // Polymer Syntax extensions\n\n    // Filter ::\n    //   Identifier\n    //   Identifier \"(\" \")\"\n    //   Identifier \"(\" FilterArguments \")\"\n\n    function parseFilter() {\n        var identifier, args;\n\n        identifier = lex();\n\n        if (identifier.type !== Token.Identifier) {\n            throwUnexpected(identifier);\n        }\n\n        args = match('(') ? parseArguments() : [];\n\n        return delegate.createFilter(identifier.value, args);\n    }\n\n    // Filters ::\n    //   \"|\" Filter\n    //   Filters \"|\" Filter\n\n    function parseFilters() {\n        while (match('|')) {\n            lex();\n            parseFilter();\n        }\n    }\n\n    // TopLevel ::\n    //   LabelledExpressions\n    //   AsExpression\n    //   InExpression\n    //   FilterExpression\n\n    // AsExpression ::\n    //   FilterExpression as Identifier\n\n    // InExpression ::\n    //   Identifier, Identifier in FilterExpression\n    //   Identifier in FilterExpression\n\n    // FilterExpression ::\n    //   Expression\n    //   Expression Filters\n\n    function parseTopLevel() {\n        skipWhitespace();\n        peek();\n\n        var expr = parseExpression();\n        if (expr) {\n            if (lookahead.value === ',' || lookahead.value == 'in' &&\n                       expr.type === Syntax.Identifier) {\n                parseInExpression(expr);\n            } else {\n                parseFilters();\n                if (lookahead.value === 'as') {\n                    parseAsExpression(expr);\n                } else {\n                    delegate.createTopLevel(expr);\n                }\n            }\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    function parseAsExpression(expr) {\n        lex();  // as\n        var identifier = lex().value;\n        delegate.createAsExpression(expr, identifier);\n    }\n\n    function parseInExpression(identifier) {\n        var indexName;\n        if (lookahead.value === ',') {\n            lex();\n            if (lookahead.type !== Token.Identifier)\n                throwUnexpected(lookahead);\n            indexName = lex().value;\n        }\n\n        lex();  // in\n        var expr = parseExpression();\n        parseFilters();\n        delegate.createInExpression(identifier.name, indexName, expr);\n    }\n\n    function parse(code, inDelegate) {\n        delegate = inDelegate;\n        source = code;\n        index = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            labelSet: {}\n        };\n\n        return parseTopLevel();\n    }\n\n    global.esprima = {\n        parse: parse\n    };\n})(this);\n",
    "// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n// Code distributed by Google as part of the polymer project is also\n// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\n(function (global) {\n  'use strict';\n\n  function prepareBinding(expressionText, name, node, filterRegistry) {\n    var expression;\n    try {\n      expression = getExpression(expressionText);\n      if (expression.scopeIdent &&\n          (node.nodeType !== Node.ELEMENT_NODE ||\n           node.tagName !== 'TEMPLATE' ||\n           (name !== 'bind' && name !== 'repeat'))) {\n        throw Error('as and in can only be used within <template bind/repeat>');\n      }\n    } catch (ex) {\n      console.error('Invalid expression syntax: ' + expressionText, ex);\n      return;\n    }\n\n    return function(model, node, oneTime) {\n      var binding = expression.getBinding(model, filterRegistry, oneTime);\n      if (expression.scopeIdent && binding) {\n        node.polymerExpressionScopeIdent_ = expression.scopeIdent;\n        if (expression.indexIdent)\n          node.polymerExpressionIndexIdent_ = expression.indexIdent;\n      }\n\n      return binding;\n    }\n  }\n\n  // TODO(rafaelw): Implement simple LRU.\n  var expressionParseCache = Object.create(null);\n\n  function getExpression(expressionText) {\n    var expression = expressionParseCache[expressionText];\n    if (!expression) {\n      var delegate = new ASTDelegate();\n      esprima.parse(expressionText, delegate);\n      expression = new Expression(delegate);\n      expressionParseCache[expressionText] = expression;\n    }\n    return expression;\n  }\n\n  function Literal(value) {\n    this.value = value;\n    this.valueFn_ = undefined;\n  }\n\n  Literal.prototype = {\n    valueFn: function() {\n      if (!this.valueFn_) {\n        var value = this.value;\n        this.valueFn_ = function() {\n          return value;\n        }\n      }\n\n      return this.valueFn_;\n    }\n  }\n\n  function IdentPath(name) {\n    this.name = name;\n    this.path = Path.get(name);\n  }\n\n  IdentPath.prototype = {\n    valueFn: function() {\n      if (!this.valueFn_) {\n        var name = this.name;\n        var path = this.path;\n        this.valueFn_ = function(model, observer) {\n          if (observer)\n            observer.addPath(model, path);\n\n          return path.getValueFrom(model);\n        }\n      }\n\n      return this.valueFn_;\n    },\n\n    setValue: function(model, newValue) {\n      if (this.path.length == 1);\n        model = findScope(model, this.path[0]);\n\n      return this.path.setValueFrom(model, newValue);\n    }\n  };\n\n  function MemberExpression(object, property, accessor) {\n    this.computed = accessor == '[';\n\n    this.dynamicDeps = typeof object == 'function' ||\n                       object.dynamicDeps ||\n                       (this.computed && !(property instanceof Literal));\n\n    this.simplePath =\n        !this.dynamicDeps &&\n        (property instanceof IdentPath || property instanceof Literal) &&\n        (object instanceof MemberExpression || object instanceof IdentPath);\n\n    this.object = this.simplePath ? object : getFn(object);\n    this.property = !this.computed || this.simplePath ?\n        property : getFn(property);\n  }\n\n  MemberExpression.prototype = {\n    get fullPath() {\n      if (!this.fullPath_) {\n\n        var parts = this.object instanceof MemberExpression ?\n            this.object.fullPath.slice() : [this.object.name];\n        parts.push(this.property instanceof IdentPath ?\n            this.property.name : this.property.value);\n        this.fullPath_ = Path.get(parts);\n      }\n\n      return this.fullPath_;\n    },\n\n    valueFn: function() {\n      if (!this.valueFn_) {\n        var object = this.object;\n\n        if (this.simplePath) {\n          var path = this.fullPath;\n\n          this.valueFn_ = function(model, observer) {\n            if (observer)\n              observer.addPath(model, path);\n\n            return path.getValueFrom(model);\n          };\n        } else if (!this.computed) {\n          var path = Path.get(this.property.name);\n\n          this.valueFn_ = function(model, observer, filterRegistry) {\n            var context = object(model, observer, filterRegistry);\n\n            if (observer)\n              observer.addPath(context, path);\n\n            return path.getValueFrom(context);\n          }\n        } else {\n          // Computed property.\n          var property = this.property;\n\n          this.valueFn_ = function(model, observer, filterRegistry) {\n            var context = object(model, observer, filterRegistry);\n            var propName = property(model, observer, filterRegistry);\n            if (observer)\n              observer.addPath(context, [propName]);\n\n            return context ? context[propName] : undefined;\n          };\n        }\n      }\n      return this.valueFn_;\n    },\n\n    setValue: function(model, newValue) {\n      if (this.simplePath) {\n        this.fullPath.setValueFrom(model, newValue);\n        return newValue;\n      }\n\n      var object = this.object(model);\n      var propName = this.property instanceof IdentPath ? this.property.name :\n          this.property(model);\n      return object[propName] = newValue;\n    }\n  };\n\n  function Filter(name, args) {\n    this.name = name;\n    this.args = [];\n    for (var i = 0; i < args.length; i++) {\n      this.args[i] = getFn(args[i]);\n    }\n  }\n\n  Filter.prototype = {\n    transform: function(model, observer, filterRegistry, toModelDirection,\n                        initialArgs) {\n      var fn = filterRegistry[this.name];\n      var context = model;\n      if (fn) {\n        context = undefined;\n      } else {\n        fn = context[this.name];\n        if (!fn) {\n          console.error('Cannot find function or filter: ' + this.name);\n          return;\n        }\n      }\n\n      // If toModelDirection is falsey, then the \"normal\" (dom-bound) direction\n      // is used. Otherwise, it looks for a 'toModel' property function on the\n      // object.\n      if (toModelDirection) {\n        fn = fn.toModel;\n      } else if (typeof fn.toDOM == 'function') {\n        fn = fn.toDOM;\n      }\n\n      if (typeof fn != 'function') {\n        console.error('Cannot find function or filter: ' + this.name);\n        return;\n      }\n\n      var args = initialArgs || [];\n      for (var i = 0; i < this.args.length; i++) {\n        args.push(getFn(this.args[i])(model, observer, filterRegistry));\n      }\n\n      return fn.apply(context, args);\n    }\n  };\n\n  function notImplemented() { throw Error('Not Implemented'); }\n\n  var unaryOperators = {\n    '+': function(v) { return +v; },\n    '-': function(v) { return -v; },\n    '!': function(v) { return !v; }\n  };\n\n  var binaryOperators = {\n    '+': function(l, r) { return l+r; },\n    '-': function(l, r) { return l-r; },\n    '*': function(l, r) { return l*r; },\n    '/': function(l, r) { return l/r; },\n    '%': function(l, r) { return l%r; },\n    '<': function(l, r) { return l<r; },\n    '>': function(l, r) { return l>r; },\n    '<=': function(l, r) { return l<=r; },\n    '>=': function(l, r) { return l>=r; },\n    '==': function(l, r) { return l==r; },\n    '!=': function(l, r) { return l!=r; },\n    '===': function(l, r) { return l===r; },\n    '!==': function(l, r) { return l!==r; },\n    '&&': function(l, r) { return l&&r; },\n    '||': function(l, r) { return l||r; },\n  };\n\n  function getFn(arg) {\n    return typeof arg == 'function' ? arg : arg.valueFn();\n  }\n\n  function ASTDelegate() {\n    this.expression = null;\n    this.filters = [];\n    this.deps = {};\n    this.currentPath = undefined;\n    this.scopeIdent = undefined;\n    this.indexIdent = undefined;\n    this.dynamicDeps = false;\n  }\n\n  ASTDelegate.prototype = {\n    createUnaryExpression: function(op, argument) {\n      if (!unaryOperators[op])\n        throw Error('Disallowed operator: ' + op);\n\n      argument = getFn(argument);\n\n      return function(model, observer, filterRegistry) {\n        return unaryOperators[op](argument(model, observer, filterRegistry));\n      };\n    },\n\n    createBinaryExpression: function(op, left, right) {\n      if (!binaryOperators[op])\n        throw Error('Disallowed operator: ' + op);\n\n      left = getFn(left);\n      right = getFn(right);\n\n      switch (op) {\n        case '||':\n          this.dynamicDeps = true;\n          return function(model, observer, filterRegistry) {\n            return left(model, observer, filterRegistry) ||\n                right(model, observer, filterRegistry);\n          };\n        case '&&':\n          this.dynamicDeps = true;\n          return function(model, observer, filterRegistry) {\n            return left(model, observer, filterRegistry) &&\n                right(model, observer, filterRegistry);\n          };\n      }\n\n      return function(model, observer, filterRegistry) {\n        return binaryOperators[op](left(model, observer, filterRegistry),\n                                   right(model, observer, filterRegistry));\n      };\n    },\n\n    createConditionalExpression: function(test, consequent, alternate) {\n      test = getFn(test);\n      consequent = getFn(consequent);\n      alternate = getFn(alternate);\n\n      this.dynamicDeps = true;\n\n      return function(model, observer, filterRegistry) {\n        return test(model, observer, filterRegistry) ?\n            consequent(model, observer, filterRegistry) :\n            alternate(model, observer, filterRegistry);\n      }\n    },\n\n    createIdentifier: function(name) {\n      var ident = new IdentPath(name);\n      ident.type = 'Identifier';\n      return ident;\n    },\n\n    createMemberExpression: function(accessor, object, property) {\n      var ex = new MemberExpression(object, property, accessor);\n      if (ex.dynamicDeps)\n        this.dynamicDeps = true;\n      return ex;\n    },\n\n    createCallExpression: function(expression, args) {\n      if (!(expression instanceof IdentPath))\n        throw Error('Only identifier function invocations are allowed');\n\n      var filter = new Filter(expression.name, args);\n\n      return function(model, observer, filterRegistry) {\n        return filter.transform(model, observer, filterRegistry, false);\n      };\n    },\n\n    createLiteral: function(token) {\n      return new Literal(token.value);\n    },\n\n    createArrayExpression: function(elements) {\n      for (var i = 0; i < elements.length; i++)\n        elements[i] = getFn(elements[i]);\n\n      return function(model, observer, filterRegistry) {\n        var arr = []\n        for (var i = 0; i < elements.length; i++)\n          arr.push(elements[i](model, observer, filterRegistry));\n        return arr;\n      }\n    },\n\n    createProperty: function(kind, key, value) {\n      return {\n        key: key instanceof IdentPath ? key.name : key.value,\n        value: value\n      };\n    },\n\n    createObjectExpression: function(properties) {\n      for (var i = 0; i < properties.length; i++)\n        properties[i].value = getFn(properties[i].value);\n\n      return function(model, observer, filterRegistry) {\n        var obj = {};\n        for (var i = 0; i < properties.length; i++)\n          obj[properties[i].key] =\n              properties[i].value(model, observer, filterRegistry);\n        return obj;\n      }\n    },\n\n    createFilter: function(name, args) {\n      this.filters.push(new Filter(name, args));\n    },\n\n    createAsExpression: function(expression, scopeIdent) {\n      this.expression = expression;\n      this.scopeIdent = scopeIdent;\n    },\n\n    createInExpression: function(scopeIdent, indexIdent, expression) {\n      this.expression = expression;\n      this.scopeIdent = scopeIdent;\n      this.indexIdent = indexIdent;\n    },\n\n    createTopLevel: function(expression) {\n      this.expression = expression;\n    },\n\n    createThisExpression: notImplemented\n  }\n\n  function ConstantObservable(value) {\n    this.value_ = value;\n  }\n\n  ConstantObservable.prototype = {\n    open: function() { return this.value_; },\n    discardChanges: function() { return this.value_; },\n    deliver: function() {},\n    close: function() {},\n  }\n\n  function Expression(delegate) {\n    this.scopeIdent = delegate.scopeIdent;\n    this.indexIdent = delegate.indexIdent;\n\n    if (!delegate.expression)\n      throw Error('No expression found.');\n\n    this.expression = delegate.expression;\n    getFn(this.expression); // forces enumeration of path dependencies\n\n    this.filters = delegate.filters;\n    this.dynamicDeps = delegate.dynamicDeps;\n  }\n\n  Expression.prototype = {\n    getBinding: function(model, filterRegistry, oneTime) {\n      if (oneTime)\n        return this.getValue(model, undefined, filterRegistry);\n\n      var observer = new CompoundObserver();\n      // captures deps.\n      var firstValue = this.getValue(model, observer, filterRegistry);\n      var firstTime = true;\n      var self = this;\n\n      function valueFn() {\n        // deps cannot have changed on first value retrieval.\n        if (firstTime) {\n          firstTime = false;\n          return firstValue;\n        }\n\n        if (self.dynamicDeps)\n          observer.startReset();\n\n        var value = self.getValue(model,\n                                  self.dynamicDeps ? observer : undefined,\n                                  filterRegistry);\n        if (self.dynamicDeps)\n          observer.finishReset();\n\n        return value;\n      }\n\n      function setValueFn(newValue) {\n        self.setValue(model, newValue, filterRegistry);\n        return newValue;\n      }\n\n      return new ObserverTransform(observer, valueFn, setValueFn, true);\n    },\n\n    getValue: function(model, observer, filterRegistry) {\n      var value = getFn(this.expression)(model, observer, filterRegistry);\n      for (var i = 0; i < this.filters.length; i++) {\n        value = this.filters[i].transform(model, observer, filterRegistry,\n            false, [value]);\n      }\n\n      return value;\n    },\n\n    setValue: function(model, newValue, filterRegistry) {\n      var count = this.filters ? this.filters.length : 0;\n      while (count-- > 0) {\n        newValue = this.filters[count].transform(model, undefined,\n            filterRegistry, true, [newValue]);\n      }\n\n      if (this.expression.setValue)\n        return this.expression.setValue(model, newValue);\n    }\n  }\n\n  /**\n   * Converts a style property name to a css property name. For example:\n   * \"WebkitUserSelect\" to \"-webkit-user-select\"\n   */\n  function convertStylePropertyName(name) {\n    return String(name).replace(/[A-Z]/g, function(c) {\n      return '-' + c.toLowerCase();\n    });\n  }\n\n  var parentScopeName = '@' + Math.random().toString(36).slice(2);\n\n  // Single ident paths must bind directly to the appropriate scope object.\n  // I.e. Pushed values in two-bindings need to be assigned to the actual model\n  // object.\n  function findScope(model, prop) {\n    while (model[parentScopeName] &&\n           !Object.prototype.hasOwnProperty.call(model, prop)) {\n      model = model[parentScopeName];\n    }\n\n    return model;\n  }\n\n  function isLiteralExpression(pathString) {\n    switch (pathString) {\n      case '':\n        return false;\n\n      case 'false':\n      case 'null':\n      case 'true':\n        return true;\n    }\n\n    if (!isNaN(Number(pathString)))\n      return true;\n\n    return false;\n  };\n\n  function PolymerExpressions() {}\n\n  PolymerExpressions.prototype = {\n    // \"built-in\" filters\n    styleObject: function(value) {\n      var parts = [];\n      for (var key in value) {\n        parts.push(convertStylePropertyName(key) + ': ' + value[key]);\n      }\n      return parts.join('; ');\n    },\n\n    tokenList: function(value) {\n      var tokens = [];\n      for (var key in value) {\n        if (value[key])\n          tokens.push(key);\n      }\n      return tokens.join(' ');\n    },\n\n    // binding delegate API\n    prepareInstancePositionChanged: function(template) {\n      var indexIdent = template.polymerExpressionIndexIdent_;\n      if (!indexIdent)\n        return;\n\n      return function(templateInstance, index) {\n        templateInstance.model[indexIdent] = index;\n      };\n    },\n\n    prepareBinding: function(pathString, name, node) {\n      var path = Path.get(pathString);\n\n      if (!isLiteralExpression(pathString) && path.valid) {\n        if (path.length == 1) {\n          return function(model, node, oneTime) {\n            if (oneTime)\n              return path.getValueFrom(model);\n\n            var scope = findScope(model, path[0]);\n            return new PathObserver(scope, path);\n          };\n        }\n        return; // bail out early if pathString is simple path.\n      }\n\n      return prepareBinding(pathString, name, node, this);\n    },\n\n    prepareInstanceModel: function(template) {\n      var scopeName = template.polymerExpressionScopeIdent_;\n      if (!scopeName)\n        return;\n\n      var parentScope = template.templateInstance ?\n          template.templateInstance.model :\n          template.model;\n\n      var indexName = template.polymerExpressionIndexIdent_;\n\n      return function(model) {\n        return createScopeObject(parentScope, model, scopeName, indexName);\n      };\n    }\n  };\n\n  var createScopeObject = ('__proto__' in {}) ?\n    function(parentScope, model, scopeName, indexName) {\n      var scope = {};\n      scope[scopeName] = model;\n      scope[indexName] = undefined;\n      scope[parentScopeName] = parentScope;\n      scope.__proto__ = parentScope;\n      return scope;\n    } :\n    function(parentScope, model, scopeName, indexName) {\n      var scope = Object.create(parentScope);\n      Object.defineProperty(scope, scopeName,\n          { value: model, configurable: true, writable: true });\n      Object.defineProperty(scope, indexName,\n          { value: undefined, configurable: true, writable: true });\n      Object.defineProperty(scope, parentScopeName,\n          { value: parentScope, configurable: true, writable: true });\n      return scope;\n    };\n\n  global.PolymerExpressions = PolymerExpressions;\n  PolymerExpressions.getExpression = getExpression;\n})(this);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\nPolymer = {\n  version: '0.4.0-d66a86e'\n};\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n// TODO(sorvell): this ensures Polymer is an object and not a function\n// Platform is currently defining it as a function to allow for async loading\n// of polymer; once we refine the loading process this likely goes away.\nif (typeof window.Polymer === 'function') {\n  Polymer = {};\n}\n\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n /*\n\tOn supported platforms, platform.js is not needed. To retain compatibility\n\twith the polyfills, we stub out minimal functionality.\n */\nif (!window.Platform) {\n  logFlags = window.logFlags || {};\n\n\n  Platform = {\n  \tflush: function() {}\n  };\n\n  CustomElements = {\n  \tuseNative: true,\n    ready: true,\n    takeRecords: function() {},\n    instanceof: function(obj, base) {\n      return obj instanceof base;\n    }\n  };\n  \n  HTMLImports = {\n  \tuseNative: true\n  };\n\n  \n  addEventListener('HTMLImportsLoaded', function() {\n    document.dispatchEvent(\n      new CustomEvent('WebComponentsReady', {bubbles: true})\n    );\n  });\n\n\n  // ShadowDOM\n  ShadowDOMPolyfill = null;\n  wrap = unwrap = function(n){\n    return n;\n  };\n\n}\n",
    "/*\r\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\n\r\n(function(scope) {\r\n\r\nvar hasNative = ('import' in document.createElement('link'));\r\nvar useNative = hasNative;\r\n\r\nisIE = /Trident/.test(navigator.userAgent);\r\n\r\n// TODO(sorvell): SD polyfill intrusion\r\nvar hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\r\nvar wrap = function(node) {\r\n  return hasShadowDOMPolyfill ? ShadowDOMPolyfill.wrapIfNeeded(node) : node;\r\n};\r\nvar mainDoc = wrap(document);\r\n    \r\n// NOTE: We cannot polyfill document.currentScript because it's not possible\r\n// both to override and maintain the ability to capture the native value;\r\n// therefore we choose to expose _currentScript both when native imports\r\n// and the polyfill are in use.\r\nvar currentScriptDescriptor = {\r\n  get: function() {\r\n    var script = HTMLImports.currentScript || document.currentScript ||\r\n        // NOTE: only works when called in synchronously executing code.\r\n        // readyState should check if `loading` but IE10 is \r\n        // interactive when scripts run so we cheat.\r\n        (document.readyState !== 'complete' ? \r\n        document.scripts[document.scripts.length - 1] : null);\r\n    return wrap(script);\r\n  },\r\n  configurable: true\r\n};\r\n\r\nObject.defineProperty(document, '_currentScript', currentScriptDescriptor);\r\nObject.defineProperty(mainDoc, '_currentScript', currentScriptDescriptor);\r\n\r\n// call a callback when all HTMLImports in the document at call (or at least\r\n//  document ready) time have loaded.\r\n// 1. ensure the document is in a ready state (has dom), then \r\n// 2. watch for loading of imports and call callback when done\r\nfunction whenImportsReady(callback, doc) {\r\n  doc = doc || mainDoc;\r\n  // if document is loading, wait and try again\r\n  whenDocumentReady(function() {\r\n    watchImportsLoad(callback, doc);\r\n  }, doc);\r\n}\r\n\r\n// call the callback when the document is in a ready state (has dom)\r\nvar requiredReadyState = isIE ? 'complete' : 'interactive';\r\nvar READY_EVENT = 'readystatechange';\r\nfunction isDocumentReady(doc) {\r\n  return (doc.readyState === 'complete' ||\r\n      doc.readyState === requiredReadyState);\r\n}\r\n\r\n// call <callback> when we ensure the document is in a ready state\r\nfunction whenDocumentReady(callback, doc) {\r\n  if (!isDocumentReady(doc)) {\r\n    var checkReady = function() {\r\n      if (doc.readyState === 'complete' || \r\n          doc.readyState === requiredReadyState) {\r\n        doc.removeEventListener(READY_EVENT, checkReady);\r\n        whenDocumentReady(callback, doc);\r\n      }\r\n    };\r\n    doc.addEventListener(READY_EVENT, checkReady);\r\n  } else if (callback) {\r\n    callback();\r\n  }\r\n}\r\n\r\nfunction markTargetLoaded(event) {\r\n  event.target.__loaded = true;\r\n}\r\n\r\n// call <callback> when we ensure all imports have loaded\r\nfunction watchImportsLoad(callback, doc) {\r\n  var imports = doc.querySelectorAll('link[rel=import]');\r\n  var loaded = 0, l = imports.length;\r\n  function checkDone(d) { \r\n    if (loaded == l) {\r\n      callback && callback();\r\n    }\r\n  }\r\n  function loadedImport(e) {\r\n    markTargetLoaded(e);\r\n    loaded++;\r\n    checkDone();\r\n  }\r\n  if (l) {\r\n    for (var i=0, imp; (i<l) && (imp=imports[i]); i++) {\r\n      if (isImportLoaded(imp)) {\r\n        loadedImport.call(imp, {target: imp});\r\n      } else {\r\n        imp.addEventListener('load', loadedImport);\r\n        imp.addEventListener('error', loadedImport);\r\n      }\r\n    }\r\n  } else {\r\n    checkDone();\r\n  }\r\n}\r\n\r\n// NOTE: test for native imports loading is based on explicitly watching\r\n// all imports (see below).\r\nfunction isImportLoaded(link) {\r\n  return useNative ? link.__loaded : link.__importParsed;\r\n}\r\n\r\n// TODO(sorvell): Workaround for \r\n// https://www.w3.org/Bugs/Public/show_bug.cgi?id=25007, should be removed when\r\n// this bug is addressed.\r\n// (1) Install a mutation observer to see when HTMLImports have loaded\r\n// (2) if this script is run during document load it will watch any existing\r\n// imports for loading.\r\n//\r\n// NOTE: The workaround has restricted functionality: (1) it's only compatible\r\n// with imports that are added to document.head since the mutation observer \r\n// watches only head for perf reasons, (2) it requires this script\r\n// to run before any imports have completed loading.\r\nif (useNative) {\r\n  new MutationObserver(function(mxns) {\r\n    for (var i=0, l=mxns.length, m; (i < l) && (m=mxns[i]); i++) {\r\n      if (m.addedNodes) {\r\n        handleImports(m.addedNodes);\r\n      }\r\n    }\r\n  }).observe(document.head, {childList: true});\r\n\r\n  function handleImports(nodes) {\r\n    for (var i=0, l=nodes.length, n; (i<l) && (n=nodes[i]); i++) {\r\n      if (isImport(n)) {\r\n        handleImport(n);  \r\n      }\r\n    }\r\n  }\r\n\r\n  function isImport(element) {\r\n    return element.localName === 'link' && element.rel === 'import';\r\n  }\r\n\r\n  function handleImport(element) {\r\n    var loaded = element.import;\r\n    if (loaded) {\r\n      markTargetLoaded({target: element});\r\n    } else {\r\n      element.addEventListener('load', markTargetLoaded);\r\n      element.addEventListener('error', markTargetLoaded);\r\n    }\r\n  }\r\n\r\n  // make sure to catch any imports that are in the process of loading\r\n  // when this script is run.\r\n  (function() {\r\n    if (document.readyState === 'loading') {\r\n      var imports = document.querySelectorAll('link[rel=import]');\r\n      for (var i=0, l=imports.length, imp; (i<l) && (imp=imports[i]); i++) {\r\n        handleImport(imp);\r\n      }\r\n    }\r\n  })();\r\n\r\n}\r\n\r\n// Fire the 'HTMLImportsLoaded' event when imports in document at load time \r\n// have loaded. This event is required to simulate the script blocking \r\n// behavior of native imports. A main document script that needs to be sure\r\n// imports have loaded should wait for this event.\r\nwhenImportsReady(function() {\r\n  HTMLImports.ready = true;\r\n  HTMLImports.readyTime = new Date().getTime();\r\n  mainDoc.dispatchEvent(\r\n    new CustomEvent('HTMLImportsLoaded', {bubbles: true})\r\n  );\r\n});\r\n\r\n// exports\r\nscope.useNative = useNative;\r\nscope.isImportLoaded = isImportLoaded;\r\nscope.whenReady = whenImportsReady;\r\nscope.isIE = isIE;\r\n\r\n// deprecated\r\nscope.whenImportsReady = whenImportsReady;\r\n\r\n})(window.HTMLImports);",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  function withDependencies(task, depends) {\n    depends = depends || [];\n    if (!depends.map) {\n      depends = [depends];\n    }\n    return task.apply(this, depends.map(marshal));\n  }\n\n  function module(name, dependsOrFactory, moduleFactory) {\n    var module;\n    switch (arguments.length) {\n      case 0:\n        return;\n      case 1:\n        module = null;\n        break;\n      case 2:\n        // dependsOrFactory is `factory` in this case\n        module = dependsOrFactory.apply(this);\n        break;\n      default:\n        // dependsOrFactory is `depends` in this case\n        module = withDependencies(moduleFactory, dependsOrFactory);\n        break;\n    }\n    modules[name] = module;\n  };\n\n  function marshal(name) {\n    return modules[name];\n  }\n\n  var modules = {};\n\n  function using(depends, task) {\n    HTMLImports.whenImportsReady(function() {\n      withDependencies(task, depends);\n    });\n  };\n\n  // exports\n\n  scope.marshal = marshal;\n  // `module` confuses commonjs detectors\n  scope.modularize = module;\n  scope.using = using;\n\n})(window);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // TODO(sorvell): It's desireable to provide a default stylesheet \n  // that's convenient for styling unresolved elements, but\n  // it's cumbersome to have to include this manually in every page.\n  // It would make sense to put inside some HTMLImport but \n  // the HTMLImports polyfill does not allow loading of stylesheets \n  // that block rendering. Therefore this injection is tolerated here.\n  var style = document.createElement('style');\n  style.textContent = ''\n      + 'body {'\n      + 'transition: opacity ease-in 0.2s;' \n      + ' } \\n'\n      + 'body[unresolved] {'\n      + 'opacity: 0; display: block; overflow: hidden;' \n      + ' } \\n'\n      ;\n  var head = document.querySelector('head');\n  head.insertBefore(style, head.firstChild);\n\n})(Platform);\n",
    "// Copyright 2012 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n(function(global) {\n  'use strict';\n\n  var testingExposeCycleCount = global.testingExposeCycleCount;\n\n  // Detect and do basic sanity checking on Object/Array.observe.\n  function detectObjectObserve() {\n    if (typeof Object.observe !== 'function' ||\n        typeof Array.observe !== 'function') {\n      return false;\n    }\n\n    var records = [];\n\n    function callback(recs) {\n      records = recs;\n    }\n\n    var test = {};\n    var arr = [];\n    Object.observe(test, callback);\n    Array.observe(arr, callback);\n    test.id = 1;\n    test.id = 2;\n    delete test.id;\n    arr.push(1, 2);\n    arr.length = 0;\n\n    Object.deliverChangeRecords(callback);\n    if (records.length !== 5)\n      return false;\n\n    if (records[0].type != 'add' ||\n        records[1].type != 'update' ||\n        records[2].type != 'delete' ||\n        records[3].type != 'splice' ||\n        records[4].type != 'splice') {\n      return false;\n    }\n\n    Object.unobserve(test, callback);\n    Array.unobserve(arr, callback);\n\n    return true;\n  }\n\n  var hasObserve = detectObjectObserve();\n\n  function detectEval() {\n    // Don't test for eval if we're running in a Chrome App environment.\n    // We check for APIs set that only exist in a Chrome App context.\n    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {\n      return false;\n    }\n\n    // Firefox OS Apps do not allow eval. This feature detection is very hacky\n    // but even if some other platform adds support for this function this code\n    // will continue to work.\n    if (navigator.getDeviceStorage) {\n      return false;\n    }\n\n    try {\n      var f = new Function('', 'return true;');\n      return f();\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  var hasEval = detectEval();\n\n  function isIndex(s) {\n    return +s === s >>> 0;\n  }\n\n  function toNumber(s) {\n    return +s;\n  }\n\n  function isObject(obj) {\n    return obj === Object(obj);\n  }\n\n  var numberIsNaN = global.Number.isNaN || function(value) {\n    return typeof value === 'number' && global.isNaN(value);\n  }\n\n  function areSameValue(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    if (numberIsNaN(left) && numberIsNaN(right))\n      return true;\n\n    return left !== left && right !== right;\n  }\n\n  var createObject = ('__proto__' in {}) ?\n    function(obj) { return obj; } :\n    function(obj) {\n      var proto = obj.__proto__;\n      if (!proto)\n        return obj;\n      var newObject = Object.create(proto);\n      Object.getOwnPropertyNames(obj).forEach(function(name) {\n        Object.defineProperty(newObject, name,\n                             Object.getOwnPropertyDescriptor(obj, name));\n      });\n      return newObject;\n    };\n\n  var identStart = '[\\$_a-zA-Z]';\n  var identPart = '[\\$_a-zA-Z0-9]';\n  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');\n\n  function getPathCharType(char) {\n    if (char === undefined)\n      return 'eof';\n\n    var code = char.charCodeAt(0);\n\n    switch(code) {\n      case 0x5B: // [\n      case 0x5D: // ]\n      case 0x2E: // .\n      case 0x22: // \"\n      case 0x27: // '\n      case 0x30: // 0\n        return char;\n\n      case 0x5F: // _\n      case 0x24: // $\n        return 'ident';\n\n      case 0x20: // Space\n      case 0x09: // Tab\n      case 0x0A: // Newline\n      case 0x0D: // Return\n      case 0xA0:  // No-break space\n      case 0xFEFF:  // Byte Order Mark\n      case 0x2028:  // Line Separator\n      case 0x2029:  // Paragraph Separator\n        return 'ws';\n    }\n\n    // a-z, A-Z\n    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))\n      return 'ident';\n\n    // 1-9\n    if (0x31 <= code && code <= 0x39)\n      return 'number';\n\n    return 'else';\n  }\n\n  var pathStateMachine = {\n    'beforePath': {\n      'ws': ['beforePath'],\n      'ident': ['inIdent', 'append'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'inPath': {\n      'ws': ['inPath'],\n      '.': ['beforeIdent'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'beforeIdent': {\n      'ws': ['beforeIdent'],\n      'ident': ['inIdent', 'append']\n    },\n\n    'inIdent': {\n      'ident': ['inIdent', 'append'],\n      '0': ['inIdent', 'append'],\n      'number': ['inIdent', 'append'],\n      'ws': ['inPath', 'push'],\n      '.': ['beforeIdent', 'push'],\n      '[': ['beforeElement', 'push'],\n      'eof': ['afterPath', 'push']\n    },\n\n    'beforeElement': {\n      'ws': ['beforeElement'],\n      '0': ['afterZero', 'append'],\n      'number': ['inIndex', 'append'],\n      \"'\": ['inSingleQuote', 'append', ''],\n      '\"': ['inDoubleQuote', 'append', '']\n    },\n\n    'afterZero': {\n      'ws': ['afterElement', 'push'],\n      ']': ['inPath', 'push']\n    },\n\n    'inIndex': {\n      '0': ['inIndex', 'append'],\n      'number': ['inIndex', 'append'],\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    },\n\n    'inSingleQuote': {\n      \"'\": ['afterElement'],\n      'eof': ['error'],\n      'else': ['inSingleQuote', 'append']\n    },\n\n    'inDoubleQuote': {\n      '\"': ['afterElement'],\n      'eof': ['error'],\n      'else': ['inDoubleQuote', 'append']\n    },\n\n    'afterElement': {\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    }\n  }\n\n  function noop() {}\n\n  function parsePath(path) {\n    var keys = [];\n    var index = -1;\n    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';\n\n    var actions = {\n      push: function() {\n        if (key === undefined)\n          return;\n\n        keys.push(key);\n        key = undefined;\n      },\n\n      append: function() {\n        if (key === undefined)\n          key = newChar\n        else\n          key += newChar;\n      }\n    };\n\n    function maybeUnescapeQuote() {\n      if (index >= path.length)\n        return;\n\n      var nextChar = path[index + 1];\n      if ((mode == 'inSingleQuote' && nextChar == \"'\") ||\n          (mode == 'inDoubleQuote' && nextChar == '\"')) {\n        index++;\n        newChar = nextChar;\n        actions.append();\n        return true;\n      }\n    }\n\n    while (mode) {\n      index++;\n      c = path[index];\n\n      if (c == '\\\\' && maybeUnescapeQuote(mode))\n        continue;\n\n      type = getPathCharType(c);\n      typeMap = pathStateMachine[mode];\n      transition = typeMap[type] || typeMap['else'] || 'error';\n\n      if (transition == 'error')\n        return; // parse error;\n\n      mode = transition[0];\n      action = actions[transition[1]] || noop;\n      newChar = transition[2] === undefined ? c : transition[2];\n      action();\n\n      if (mode === 'afterPath') {\n        return keys;\n      }\n    }\n\n    return; // parse error\n  }\n\n  function isIdent(s) {\n    return identRegExp.test(s);\n  }\n\n  var constructorIsPrivate = {};\n\n  function Path(parts, privateToken) {\n    if (privateToken !== constructorIsPrivate)\n      throw Error('Use Path.get to retrieve path objects');\n\n    for (var i = 0; i < parts.length; i++) {\n      this.push(String(parts[i]));\n    }\n\n    if (hasEval && this.length) {\n      this.getValueFrom = this.compiledGetValueFromFn();\n    }\n  }\n\n  // TODO(rafaelw): Make simple LRU cache\n  var pathCache = {};\n\n  function getPath(pathString) {\n    if (pathString instanceof Path)\n      return pathString;\n\n    if (pathString == null || pathString.length == 0)\n      pathString = '';\n\n    if (typeof pathString != 'string') {\n      if (isIndex(pathString.length)) {\n        // Constructed with array-like (pre-parsed) keys\n        return new Path(pathString, constructorIsPrivate);\n      }\n\n      pathString = String(pathString);\n    }\n\n    var path = pathCache[pathString];\n    if (path)\n      return path;\n\n    var parts = parsePath(pathString);\n    if (!parts)\n      return invalidPath;\n\n    var path = new Path(parts, constructorIsPrivate);\n    pathCache[pathString] = path;\n    return path;\n  }\n\n  Path.get = getPath;\n\n  function formatAccessor(key) {\n    if (isIndex(key)) {\n      return '[' + key + ']';\n    } else {\n      return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]';\n    }\n  }\n\n  Path.prototype = createObject({\n    __proto__: [],\n    valid: true,\n\n    toString: function() {\n      var pathString = '';\n      for (var i = 0; i < this.length; i++) {\n        var key = this[i];\n        if (isIdent(key)) {\n          pathString += i ? '.' + key : key;\n        } else {\n          pathString += formatAccessor(key);\n        }\n      }\n\n      return pathString;\n    },\n\n    getValueFrom: function(obj, directObserver) {\n      for (var i = 0; i < this.length; i++) {\n        if (obj == null)\n          return;\n        obj = obj[this[i]];\n      }\n      return obj;\n    },\n\n    iterateObjects: function(obj, observe) {\n      for (var i = 0; i < this.length; i++) {\n        if (i)\n          obj = obj[this[i - 1]];\n        if (!isObject(obj))\n          return;\n        observe(obj, this[0]);\n      }\n    },\n\n    compiledGetValueFromFn: function() {\n      var str = '';\n      var pathString = 'obj';\n      str += 'if (obj != null';\n      var i = 0;\n      var key;\n      for (; i < (this.length - 1); i++) {\n        key = this[i];\n        pathString += isIdent(key) ? '.' + key : formatAccessor(key);\n        str += ' &&\\n     ' + pathString + ' != null';\n      }\n      str += ')\\n';\n\n      var key = this[i];\n      pathString += isIdent(key) ? '.' + key : formatAccessor(key);\n\n      str += '  return ' + pathString + ';\\nelse\\n  return undefined;';\n      return new Function('obj', str);\n    },\n\n    setValueFrom: function(obj, value) {\n      if (!this.length)\n        return false;\n\n      for (var i = 0; i < this.length - 1; i++) {\n        if (!isObject(obj))\n          return false;\n        obj = obj[this[i]];\n      }\n\n      if (!isObject(obj))\n        return false;\n\n      obj[this[i]] = value;\n      return true;\n    }\n  });\n\n  var invalidPath = new Path('', constructorIsPrivate);\n  invalidPath.valid = false;\n  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};\n\n  var MAX_DIRTY_CHECK_CYCLES = 1000;\n\n  function dirtyCheck(observer) {\n    var cycles = 0;\n    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {\n      cycles++;\n    }\n    if (testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    return cycles > 0;\n  }\n\n  function objectIsEmpty(object) {\n    for (var prop in object)\n      return false;\n    return true;\n  }\n\n  function diffIsEmpty(diff) {\n    return objectIsEmpty(diff.added) &&\n           objectIsEmpty(diff.removed) &&\n           objectIsEmpty(diff.changed);\n  }\n\n  function diffObjectFromOldObject(object, oldObject) {\n    var added = {};\n    var removed = {};\n    var changed = {};\n\n    for (var prop in oldObject) {\n      var newValue = object[prop];\n\n      if (newValue !== undefined && newValue === oldObject[prop])\n        continue;\n\n      if (!(prop in object)) {\n        removed[prop] = undefined;\n        continue;\n      }\n\n      if (newValue !== oldObject[prop])\n        changed[prop] = newValue;\n    }\n\n    for (var prop in object) {\n      if (prop in oldObject)\n        continue;\n\n      added[prop] = object[prop];\n    }\n\n    if (Array.isArray(object) && object.length !== oldObject.length)\n      changed.length = object.length;\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  var eomTasks = [];\n  function runEOMTasks() {\n    if (!eomTasks.length)\n      return false;\n\n    for (var i = 0; i < eomTasks.length; i++) {\n      eomTasks[i]();\n    }\n    eomTasks.length = 0;\n    return true;\n  }\n\n  var runEOM = hasObserve ? (function(){\n    var eomObj = { pingPong: true };\n    var eomRunScheduled = false;\n\n    Object.observe(eomObj, function() {\n      runEOMTasks();\n      eomRunScheduled = false;\n    });\n\n    return function(fn) {\n      eomTasks.push(fn);\n      if (!eomRunScheduled) {\n        eomRunScheduled = true;\n        eomObj.pingPong = !eomObj.pingPong;\n      }\n    };\n  })() :\n  (function() {\n    return function(fn) {\n      eomTasks.push(fn);\n    };\n  })();\n\n  var observedObjectCache = [];\n\n  function newObservedObject() {\n    var observer;\n    var object;\n    var discardRecords = false;\n    var first = true;\n\n    function callback(records) {\n      if (observer && observer.state_ === OPENED && !discardRecords)\n        observer.check_(records);\n    }\n\n    return {\n      open: function(obs) {\n        if (observer)\n          throw Error('ObservedObject in use');\n\n        if (!first)\n          Object.deliverChangeRecords(callback);\n\n        observer = obs;\n        first = false;\n      },\n      observe: function(obj, arrayObserve) {\n        object = obj;\n        if (arrayObserve)\n          Array.observe(object, callback);\n        else\n          Object.observe(object, callback);\n      },\n      deliver: function(discard) {\n        discardRecords = discard;\n        Object.deliverChangeRecords(callback);\n        discardRecords = false;\n      },\n      close: function() {\n        observer = undefined;\n        Object.unobserve(object, callback);\n        observedObjectCache.push(this);\n      }\n    };\n  }\n\n  /*\n   * The observedSet abstraction is a perf optimization which reduces the total\n   * number of Object.observe observations of a set of objects. The idea is that\n   * groups of Observers will have some object dependencies in common and this\n   * observed set ensures that each object in the transitive closure of\n   * dependencies is only observed once. The observedSet acts as a write barrier\n   * such that whenever any change comes through, all Observers are checked for\n   * changed values.\n   *\n   * Note that this optimization is explicitly moving work from setup-time to\n   * change-time.\n   *\n   * TODO(rafaelw): Implement \"garbage collection\". In order to move work off\n   * the critical path, when Observers are closed, their observed objects are\n   * not Object.unobserve(d). As a result, it's possible that if the observedSet\n   * is kept open, but some Observers have been closed, it could cause \"leaks\"\n   * (prevent otherwise collectable objects from being collected). At some\n   * point, we should implement incremental \"gc\" which keeps a list of\n   * observedSets which may need clean-up and does small amounts of cleanup on a\n   * timeout until all is clean.\n   */\n\n  function getObservedObject(observer, object, arrayObserve) {\n    var dir = observedObjectCache.pop() || newObservedObject();\n    dir.open(observer);\n    dir.observe(object, arrayObserve);\n    return dir;\n  }\n\n  var observedSetCache = [];\n\n  function newObservedSet() {\n    var observerCount = 0;\n    var observers = [];\n    var objects = [];\n    var rootObj;\n    var rootObjProps;\n\n    function observe(obj, prop) {\n      if (!obj)\n        return;\n\n      if (obj === rootObj)\n        rootObjProps[prop] = true;\n\n      if (objects.indexOf(obj) < 0) {\n        objects.push(obj);\n        Object.observe(obj, callback);\n      }\n\n      observe(Object.getPrototypeOf(obj), prop);\n    }\n\n    function allRootObjNonObservedProps(recs) {\n      for (var i = 0; i < recs.length; i++) {\n        var rec = recs[i];\n        if (rec.object !== rootObj ||\n            rootObjProps[rec.name] ||\n            rec.type === 'setPrototype') {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function callback(recs) {\n      if (allRootObjNonObservedProps(recs))\n        return;\n\n      var observer;\n      for (var i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.iterateObjects_(observe);\n        }\n      }\n\n      for (var i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.check_();\n        }\n      }\n    }\n\n    var record = {\n      object: undefined,\n      objects: objects,\n      open: function(obs, object) {\n        if (!rootObj) {\n          rootObj = object;\n          rootObjProps = {};\n        }\n\n        observers.push(obs);\n        observerCount++;\n        obs.iterateObjects_(observe);\n      },\n      close: function(obs) {\n        observerCount--;\n        if (observerCount > 0) {\n          return;\n        }\n\n        for (var i = 0; i < objects.length; i++) {\n          Object.unobserve(objects[i], callback);\n          Observer.unobservedCount++;\n        }\n\n        observers.length = 0;\n        objects.length = 0;\n        rootObj = undefined;\n        rootObjProps = undefined;\n        observedSetCache.push(this);\n      }\n    };\n\n    return record;\n  }\n\n  var lastObservedSet;\n\n  function getObservedSet(observer, obj) {\n    if (!lastObservedSet || lastObservedSet.object !== obj) {\n      lastObservedSet = observedSetCache.pop() || newObservedSet();\n      lastObservedSet.object = obj;\n    }\n    lastObservedSet.open(observer, obj);\n    return lastObservedSet;\n  }\n\n  var UNOPENED = 0;\n  var OPENED = 1;\n  var CLOSED = 2;\n  var RESETTING = 3;\n\n  var nextObserverId = 1;\n\n  function Observer() {\n    this.state_ = UNOPENED;\n    this.callback_ = undefined;\n    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef\n    this.directObserver_ = undefined;\n    this.value_ = undefined;\n    this.id_ = nextObserverId++;\n  }\n\n  Observer.prototype = {\n    open: function(callback, target) {\n      if (this.state_ != UNOPENED)\n        throw Error('Observer has already been opened.');\n\n      addToAll(this);\n      this.callback_ = callback;\n      this.target_ = target;\n      this.connect_();\n      this.state_ = OPENED;\n      return this.value_;\n    },\n\n    close: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      removeFromAll(this);\n      this.disconnect_();\n      this.value_ = undefined;\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.state_ = CLOSED;\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      dirtyCheck(this);\n    },\n\n    report_: function(changes) {\n      try {\n        this.callback_.apply(this.target_, changes);\n      } catch (ex) {\n        Observer._errorThrownDuringCallback = true;\n        console.error('Exception caught during observer callback: ' +\n                       (ex.stack || ex));\n      }\n    },\n\n    discardChanges: function() {\n      this.check_(undefined, true);\n      return this.value_;\n    }\n  }\n\n  var collectObservers = !hasObserve;\n  var allObservers;\n  Observer._allObserversCount = 0;\n\n  if (collectObservers) {\n    allObservers = [];\n  }\n\n  function addToAll(observer) {\n    Observer._allObserversCount++;\n    if (!collectObservers)\n      return;\n\n    allObservers.push(observer);\n  }\n\n  function removeFromAll(observer) {\n    Observer._allObserversCount--;\n  }\n\n  var runningMicrotaskCheckpoint = false;\n\n  var hasDebugForceFullDelivery = hasObserve && hasEval && (function() {\n    try {\n      eval('%RunMicrotasks()');\n      return true;\n    } catch (ex) {\n      return false;\n    }\n  })();\n\n  global.Platform = global.Platform || {};\n\n  global.Platform.performMicrotaskCheckpoint = function() {\n    if (runningMicrotaskCheckpoint)\n      return;\n\n    if (hasDebugForceFullDelivery) {\n      eval('%RunMicrotasks()');\n      return;\n    }\n\n    if (!collectObservers)\n      return;\n\n    runningMicrotaskCheckpoint = true;\n\n    var cycles = 0;\n    var anyChanged, toCheck;\n\n    do {\n      cycles++;\n      toCheck = allObservers;\n      allObservers = [];\n      anyChanged = false;\n\n      for (var i = 0; i < toCheck.length; i++) {\n        var observer = toCheck[i];\n        if (observer.state_ != OPENED)\n          continue;\n\n        if (observer.check_())\n          anyChanged = true;\n\n        allObservers.push(observer);\n      }\n      if (runEOMTasks())\n        anyChanged = true;\n    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);\n\n    if (testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    runningMicrotaskCheckpoint = false;\n  };\n\n  if (collectObservers) {\n    global.Platform.clearObservers = function() {\n      allObservers = [];\n    };\n  }\n\n  function ObjectObserver(object) {\n    Observer.call(this);\n    this.value_ = object;\n    this.oldObject_ = undefined;\n  }\n\n  ObjectObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    arrayObserve: false,\n\n    connect_: function(callback, target) {\n      if (hasObserve) {\n        this.directObserver_ = getObservedObject(this, this.value_,\n                                                 this.arrayObserve);\n      } else {\n        this.oldObject_ = this.copyObject(this.value_);\n      }\n\n    },\n\n    copyObject: function(object) {\n      var copy = Array.isArray(object) ? [] : {};\n      for (var prop in object) {\n        copy[prop] = object[prop];\n      };\n      if (Array.isArray(object))\n        copy.length = object.length;\n      return copy;\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var diff;\n      var oldValues;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n\n        oldValues = {};\n        diff = diffObjectFromChangeRecords(this.value_, changeRecords,\n                                           oldValues);\n      } else {\n        oldValues = this.oldObject_;\n        diff = diffObjectFromOldObject(this.value_, this.oldObject_);\n      }\n\n      if (diffIsEmpty(diff))\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([\n        diff.added || {},\n        diff.removed || {},\n        diff.changed || {},\n        function(property) {\n          return oldValues[property];\n        }\n      ]);\n\n      return true;\n    },\n\n    disconnect_: function() {\n      if (hasObserve) {\n        this.directObserver_.close();\n        this.directObserver_ = undefined;\n      } else {\n        this.oldObject_ = undefined;\n      }\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      if (hasObserve)\n        this.directObserver_.deliver(false);\n      else\n        dirtyCheck(this);\n    },\n\n    discardChanges: function() {\n      if (this.directObserver_)\n        this.directObserver_.deliver(true);\n      else\n        this.oldObject_ = this.copyObject(this.value_);\n\n      return this.value_;\n    }\n  });\n\n  function ArrayObserver(array) {\n    if (!Array.isArray(array))\n      throw Error('Provided object is not an Array');\n    ObjectObserver.call(this, array);\n  }\n\n  ArrayObserver.prototype = createObject({\n\n    __proto__: ObjectObserver.prototype,\n\n    arrayObserve: true,\n\n    copyObject: function(arr) {\n      return arr.slice();\n    },\n\n    check_: function(changeRecords) {\n      var splices;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n        splices = projectArraySplices(this.value_, changeRecords);\n      } else {\n        splices = calcSplices(this.value_, 0, this.value_.length,\n                              this.oldObject_, 0, this.oldObject_.length);\n      }\n\n      if (!splices || !splices.length)\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([splices]);\n      return true;\n    }\n  });\n\n  ArrayObserver.applySplices = function(previous, current, splices) {\n    splices.forEach(function(splice) {\n      var spliceArgs = [splice.index, splice.removed.length];\n      var addIndex = splice.index;\n      while (addIndex < splice.index + splice.addedCount) {\n        spliceArgs.push(current[addIndex]);\n        addIndex++;\n      }\n\n      Array.prototype.splice.apply(previous, spliceArgs);\n    });\n  };\n\n  function PathObserver(object, path) {\n    Observer.call(this);\n\n    this.object_ = object;\n    this.path_ = getPath(path);\n    this.directObserver_ = undefined;\n  }\n\n  PathObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    get path() {\n      return this.path_;\n    },\n\n    connect_: function() {\n      if (hasObserve)\n        this.directObserver_ = getObservedSet(this, this.object_);\n\n      this.check_(undefined, true);\n    },\n\n    disconnect_: function() {\n      this.value_ = undefined;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    iterateObjects_: function(observe) {\n      this.path_.iterateObjects(this.object_, observe);\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValue = this.value_;\n      this.value_ = this.path_.getValueFrom(this.object_);\n      if (skipChanges || areSameValue(this.value_, oldValue))\n        return false;\n\n      this.report_([this.value_, oldValue, this]);\n      return true;\n    },\n\n    setValue: function(newValue) {\n      if (this.path_)\n        this.path_.setValueFrom(this.object_, newValue);\n    }\n  });\n\n  function CompoundObserver(reportChangesOnOpen) {\n    Observer.call(this);\n\n    this.reportChangesOnOpen_ = reportChangesOnOpen;\n    this.value_ = [];\n    this.directObserver_ = undefined;\n    this.observed_ = [];\n  }\n\n  var observerSentinel = {};\n\n  CompoundObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    connect_: function() {\n      if (hasObserve) {\n        var object;\n        var needsDirectObserver = false;\n        for (var i = 0; i < this.observed_.length; i += 2) {\n          object = this.observed_[i]\n          if (object !== observerSentinel) {\n            needsDirectObserver = true;\n            break;\n          }\n        }\n\n        if (needsDirectObserver)\n          this.directObserver_ = getObservedSet(this, object);\n      }\n\n      this.check_(undefined, !this.reportChangesOnOpen_);\n    },\n\n    disconnect_: function() {\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        if (this.observed_[i] === observerSentinel)\n          this.observed_[i + 1].close();\n      }\n      this.observed_.length = 0;\n      this.value_.length = 0;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    addPath: function(object, path) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add paths once started.');\n\n      var path = getPath(path);\n      this.observed_.push(object, path);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = path.getValueFrom(object);\n    },\n\n    addObserver: function(observer) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add observers once started.');\n\n      this.observed_.push(observerSentinel, observer);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = observer.open(this.deliver, this);\n    },\n\n    startReset: function() {\n      if (this.state_ != OPENED)\n        throw Error('Can only reset while open');\n\n      this.state_ = RESETTING;\n      this.disconnect_();\n    },\n\n    finishReset: function() {\n      if (this.state_ != RESETTING)\n        throw Error('Can only finishReset after startReset');\n      this.state_ = OPENED;\n      this.connect_();\n\n      return this.value_;\n    },\n\n    iterateObjects_: function(observe) {\n      var object;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        object = this.observed_[i]\n        if (object !== observerSentinel)\n          this.observed_[i + 1].iterateObjects(object, observe)\n      }\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValues;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        var object = this.observed_[i];\n        var path = this.observed_[i+1];\n        var value;\n        if (object === observerSentinel) {\n          var observable = path;\n          value = this.state_ === UNOPENED ?\n              observable.open(this.deliver, this) :\n              observable.discardChanges();\n        } else {\n          value = path.getValueFrom(object);\n        }\n\n        if (skipChanges) {\n          this.value_[i / 2] = value;\n          continue;\n        }\n\n        if (areSameValue(value, this.value_[i / 2]))\n          continue;\n\n        oldValues = oldValues || [];\n        oldValues[i / 2] = this.value_[i / 2];\n        this.value_[i / 2] = value;\n      }\n\n      if (!oldValues)\n        return false;\n\n      // TODO(rafaelw): Having observed_ as the third callback arg here is\n      // pretty lame API. Fix.\n      this.report_([this.value_, oldValues, this.observed_]);\n      return true;\n    }\n  });\n\n  function identFn(value) { return value; }\n\n  function ObserverTransform(observable, getValueFn, setValueFn,\n                             dontPassThroughSet) {\n    this.callback_ = undefined;\n    this.target_ = undefined;\n    this.value_ = undefined;\n    this.observable_ = observable;\n    this.getValueFn_ = getValueFn || identFn;\n    this.setValueFn_ = setValueFn || identFn;\n    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this\n    // at the moment because of a bug in it's dependency tracking.\n    this.dontPassThroughSet_ = dontPassThroughSet;\n  }\n\n  ObserverTransform.prototype = {\n    open: function(callback, target) {\n      this.callback_ = callback;\n      this.target_ = target;\n      this.value_ =\n          this.getValueFn_(this.observable_.open(this.observedCallback_, this));\n      return this.value_;\n    },\n\n    observedCallback_: function(value) {\n      value = this.getValueFn_(value);\n      if (areSameValue(value, this.value_))\n        return;\n      var oldValue = this.value_;\n      this.value_ = value;\n      this.callback_.call(this.target_, this.value_, oldValue);\n    },\n\n    discardChanges: function() {\n      this.value_ = this.getValueFn_(this.observable_.discardChanges());\n      return this.value_;\n    },\n\n    deliver: function() {\n      return this.observable_.deliver();\n    },\n\n    setValue: function(value) {\n      value = this.setValueFn_(value);\n      if (!this.dontPassThroughSet_ && this.observable_.setValue)\n        return this.observable_.setValue(value);\n    },\n\n    close: function() {\n      if (this.observable_)\n        this.observable_.close();\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.observable_ = undefined;\n      this.value_ = undefined;\n      this.getValueFn_ = undefined;\n      this.setValueFn_ = undefined;\n    }\n  }\n\n  var expectedRecordTypes = {\n    add: true,\n    update: true,\n    delete: true\n  };\n\n  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {\n    var added = {};\n    var removed = {};\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      if (!expectedRecordTypes[record.type]) {\n        console.error('Unknown changeRecord type: ' + record.type);\n        console.error(record);\n        continue;\n      }\n\n      if (!(record.name in oldValues))\n        oldValues[record.name] = record.oldValue;\n\n      if (record.type == 'update')\n        continue;\n\n      if (record.type == 'add') {\n        if (record.name in removed)\n          delete removed[record.name];\n        else\n          added[record.name] = true;\n\n        continue;\n      }\n\n      // type = 'delete'\n      if (record.name in added) {\n        delete added[record.name];\n        delete oldValues[record.name];\n      } else {\n        removed[record.name] = true;\n      }\n    }\n\n    for (var prop in added)\n      added[prop] = object[prop];\n\n    for (var prop in removed)\n      removed[prop] = undefined;\n\n    var changed = {};\n    for (var prop in oldValues) {\n      if (prop in added || prop in removed)\n        continue;\n\n      var newValue = object[prop];\n      if (oldValues[prop] !== newValue)\n        changed[prop] = newValue;\n    }\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  function newSplice(index, removed, addedCount) {\n    return {\n      index: index,\n      removed: removed,\n      addedCount: addedCount\n    };\n  }\n\n  var EDIT_LEAVE = 0;\n  var EDIT_UPDATE = 1;\n  var EDIT_ADD = 2;\n  var EDIT_DELETE = 3;\n\n  function ArraySplice() {}\n\n  ArraySplice.prototype = {\n\n    // Note: This function is *based* on the computation of the Levenshtein\n    // \"edit\" distance. The one change is that \"updates\" are treated as two\n    // edits - not one. With Array splices, an update is really a delete\n    // followed by an add. By retaining this, we optimize for \"keeping\" the\n    // maximum array items in the original array. For example:\n    //\n    //   'xxxx123' -> '123yyyy'\n    //\n    // With 1-edit updates, the shortest path would be just to update all seven\n    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n    // leaves the substring '123' intact.\n    calcEditDistances: function(current, currentStart, currentEnd,\n                                old, oldStart, oldEnd) {\n      // \"Deletion\" columns\n      var rowCount = oldEnd - oldStart + 1;\n      var columnCount = currentEnd - currentStart + 1;\n      var distances = new Array(rowCount);\n\n      // \"Addition\" rows. Initialize null column.\n      for (var i = 0; i < rowCount; i++) {\n        distances[i] = new Array(columnCount);\n        distances[i][0] = i;\n      }\n\n      // Initialize null row\n      for (var j = 0; j < columnCount; j++)\n        distances[0][j] = j;\n\n      for (var i = 1; i < rowCount; i++) {\n        for (var j = 1; j < columnCount; j++) {\n          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\n            distances[i][j] = distances[i - 1][j - 1];\n          else {\n            var north = distances[i - 1][j] + 1;\n            var west = distances[i][j - 1] + 1;\n            distances[i][j] = north < west ? north : west;\n          }\n        }\n      }\n\n      return distances;\n    },\n\n    // This starts at the final weight, and walks \"backward\" by finding\n    // the minimum previous weight recursively until the origin of the weight\n    // matrix.\n    spliceOperationsFromEditDistances: function(distances) {\n      var i = distances.length - 1;\n      var j = distances[0].length - 1;\n      var current = distances[i][j];\n      var edits = [];\n      while (i > 0 || j > 0) {\n        if (i == 0) {\n          edits.push(EDIT_ADD);\n          j--;\n          continue;\n        }\n        if (j == 0) {\n          edits.push(EDIT_DELETE);\n          i--;\n          continue;\n        }\n        var northWest = distances[i - 1][j - 1];\n        var west = distances[i - 1][j];\n        var north = distances[i][j - 1];\n\n        var min;\n        if (west < north)\n          min = west < northWest ? west : northWest;\n        else\n          min = north < northWest ? north : northWest;\n\n        if (min == northWest) {\n          if (northWest == current) {\n            edits.push(EDIT_LEAVE);\n          } else {\n            edits.push(EDIT_UPDATE);\n            current = northWest;\n          }\n          i--;\n          j--;\n        } else if (min == west) {\n          edits.push(EDIT_DELETE);\n          i--;\n          current = west;\n        } else {\n          edits.push(EDIT_ADD);\n          j--;\n          current = north;\n        }\n      }\n\n      edits.reverse();\n      return edits;\n    },\n\n    /**\n     * Splice Projection functions:\n     *\n     * A splice map is a representation of how a previous array of items\n     * was transformed into a new array of items. Conceptually it is a list of\n     * tuples of\n     *\n     *   <index, removed, addedCount>\n     *\n     * which are kept in ascending index order of. The tuple represents that at\n     * the |index|, |removed| sequence of items were removed, and counting forward\n     * from |index|, |addedCount| items were added.\n     */\n\n    /**\n     * Lacking individual splice mutation information, the minimal set of\n     * splices can be synthesized given the previous state and final state of an\n     * array. The basic approach is to calculate the edit distance matrix and\n     * choose the shortest path through it.\n     *\n     * Complexity: O(l * p)\n     *   l: The length of the current array\n     *   p: The length of the old array\n     */\n    calcSplices: function(current, currentStart, currentEnd,\n                          old, oldStart, oldEnd) {\n      var prefixCount = 0;\n      var suffixCount = 0;\n\n      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n      if (currentStart == 0 && oldStart == 0)\n        prefixCount = this.sharedPrefix(current, old, minLength);\n\n      if (currentEnd == current.length && oldEnd == old.length)\n        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\n      currentStart += prefixCount;\n      oldStart += prefixCount;\n      currentEnd -= suffixCount;\n      oldEnd -= suffixCount;\n\n      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n        return [];\n\n      if (currentStart == currentEnd) {\n        var splice = newSplice(currentStart, [], 0);\n        while (oldStart < oldEnd)\n          splice.removed.push(old[oldStart++]);\n\n        return [ splice ];\n      } else if (oldStart == oldEnd)\n        return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n      var ops = this.spliceOperationsFromEditDistances(\n          this.calcEditDistances(current, currentStart, currentEnd,\n                                 old, oldStart, oldEnd));\n\n      var splice = undefined;\n      var splices = [];\n      var index = currentStart;\n      var oldIndex = oldStart;\n      for (var i = 0; i < ops.length; i++) {\n        switch(ops[i]) {\n          case EDIT_LEAVE:\n            if (splice) {\n              splices.push(splice);\n              splice = undefined;\n            }\n\n            index++;\n            oldIndex++;\n            break;\n          case EDIT_UPDATE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n          case EDIT_ADD:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n            break;\n          case EDIT_DELETE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n        }\n      }\n\n      if (splice) {\n        splices.push(splice);\n      }\n      return splices;\n    },\n\n    sharedPrefix: function(current, old, searchLength) {\n      for (var i = 0; i < searchLength; i++)\n        if (!this.equals(current[i], old[i]))\n          return i;\n      return searchLength;\n    },\n\n    sharedSuffix: function(current, old, searchLength) {\n      var index1 = current.length;\n      var index2 = old.length;\n      var count = 0;\n      while (count < searchLength && this.equals(current[--index1], old[--index2]))\n        count++;\n\n      return count;\n    },\n\n    calculateSplices: function(current, previous) {\n      return this.calcSplices(current, 0, current.length, previous, 0,\n                              previous.length);\n    },\n\n    equals: function(currentValue, previousValue) {\n      return currentValue === previousValue;\n    }\n  };\n\n  var arraySplice = new ArraySplice();\n\n  function calcSplices(current, currentStart, currentEnd,\n                       old, oldStart, oldEnd) {\n    return arraySplice.calcSplices(current, currentStart, currentEnd,\n                                   old, oldStart, oldEnd);\n  }\n\n  function intersect(start1, end1, start2, end2) {\n    // Disjoint\n    if (end1 < start2 || end2 < start1)\n      return -1;\n\n    // Adjacent\n    if (end1 == start2 || end2 == start1)\n      return 0;\n\n    // Non-zero intersect, span1 first\n    if (start1 < start2) {\n      if (end1 < end2)\n        return end1 - start2; // Overlap\n      else\n        return end2 - start2; // Contained\n    } else {\n      // Non-zero intersect, span2 first\n      if (end2 < end1)\n        return end2 - start1; // Overlap\n      else\n        return end1 - start1; // Contained\n    }\n  }\n\n  function mergeSplice(splices, index, removed, addedCount) {\n\n    var splice = newSplice(index, removed, addedCount);\n\n    var inserted = false;\n    var insertionOffset = 0;\n\n    for (var i = 0; i < splices.length; i++) {\n      var current = splices[i];\n      current.index += insertionOffset;\n\n      if (inserted)\n        continue;\n\n      var intersectCount = intersect(splice.index,\n                                     splice.index + splice.removed.length,\n                                     current.index,\n                                     current.index + current.addedCount);\n\n      if (intersectCount >= 0) {\n        // Merge the two splices\n\n        splices.splice(i, 1);\n        i--;\n\n        insertionOffset -= current.addedCount - current.removed.length;\n\n        splice.addedCount += current.addedCount - intersectCount;\n        var deleteCount = splice.removed.length +\n                          current.removed.length - intersectCount;\n\n        if (!splice.addedCount && !deleteCount) {\n          // merged splice is a noop. discard.\n          inserted = true;\n        } else {\n          var removed = current.removed;\n\n          if (splice.index < current.index) {\n            // some prefix of splice.removed is prepended to current.removed.\n            var prepend = splice.removed.slice(0, current.index - splice.index);\n            Array.prototype.push.apply(prepend, removed);\n            removed = prepend;\n          }\n\n          if (splice.index + splice.removed.length > current.index + current.addedCount) {\n            // some suffix of splice.removed is appended to current.removed.\n            var append = splice.removed.slice(current.index + current.addedCount - splice.index);\n            Array.prototype.push.apply(removed, append);\n          }\n\n          splice.removed = removed;\n          if (current.index < splice.index) {\n            splice.index = current.index;\n          }\n        }\n      } else if (splice.index < current.index) {\n        // Insert splice here.\n\n        inserted = true;\n\n        splices.splice(i, 0, splice);\n        i++;\n\n        var offset = splice.addedCount - splice.removed.length\n        current.index += offset;\n        insertionOffset += offset;\n      }\n    }\n\n    if (!inserted)\n      splices.push(splice);\n  }\n\n  function createInitialSplices(array, changeRecords) {\n    var splices = [];\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      switch(record.type) {\n        case 'splice':\n          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);\n          break;\n        case 'add':\n        case 'update':\n        case 'delete':\n          if (!isIndex(record.name))\n            continue;\n          var index = toNumber(record.name);\n          if (index < 0)\n            continue;\n          mergeSplice(splices, index, [record.oldValue], 1);\n          break;\n        default:\n          console.error('Unexpected record type: ' + JSON.stringify(record));\n          break;\n      }\n    }\n\n    return splices;\n  }\n\n  function projectArraySplices(array, changeRecords) {\n    var splices = [];\n\n    createInitialSplices(array, changeRecords).forEach(function(splice) {\n      if (splice.addedCount == 1 && splice.removed.length == 1) {\n        if (splice.removed[0] !== array[splice.index])\n          splices.push(splice);\n\n        return\n      };\n\n      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,\n                                           splice.removed, 0, splice.removed.length));\n    });\n\n    return splices;\n  }\n\n  global.Observer = Observer;\n  global.Observer.runEOM_ = runEOM;\n  global.Observer.observerSentinel_ = observerSentinel; // for testing.\n  global.Observer.hasObjectObserve = hasObserve;\n  global.ArrayObserver = ArrayObserver;\n  global.ArrayObserver.calculateSplices = function(current, previous) {\n    return arraySplice.calculateSplices(current, previous);\n  };\n\n  global.ArraySplice = ArraySplice;\n  global.ObjectObserver = ObjectObserver;\n  global.PathObserver = PathObserver;\n  global.CompoundObserver = CompoundObserver;\n  global.Path = Path;\n  global.ObserverTransform = ObserverTransform;\n})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);\n",
    "// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n// Code distributed by Google as part of the polymer project is also\n// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\n(function(global) {\n  'use strict';\n\n  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);\n\n  function getTreeScope(node) {\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n\n    return typeof node.getElementById === 'function' ? node : null;\n  }\n\n  Node.prototype.bind = function(name, observable) {\n    console.error('Unhandled binding to Node: ', this, name, observable);\n  };\n\n  Node.prototype.bindFinished = function() {};\n\n  function updateBindings(node, name, binding) {\n    var bindings = node.bindings_;\n    if (!bindings)\n      bindings = node.bindings_ = {};\n\n    if (bindings[name])\n      binding[name].close();\n\n    return bindings[name] = binding;\n  }\n\n  function returnBinding(node, name, binding) {\n    return binding;\n  }\n\n  function sanitizeValue(value) {\n    return value == null ? '' : value;\n  }\n\n  function updateText(node, value) {\n    node.data = sanitizeValue(value);\n  }\n\n  function textBinding(node) {\n    return function(value) {\n      return updateText(node, value);\n    };\n  }\n\n  var maybeUpdateBindings = returnBinding;\n\n  Object.defineProperty(Platform, 'enableBindingsReflection', {\n    get: function() {\n      return maybeUpdateBindings === updateBindings;\n    },\n    set: function(enable) {\n      maybeUpdateBindings = enable ? updateBindings : returnBinding;\n      return enable;\n    },\n    configurable: true\n  });\n\n  Text.prototype.bind = function(name, value, oneTime) {\n    if (name !== 'textContent')\n      return Node.prototype.bind.call(this, name, value, oneTime);\n\n    if (oneTime)\n      return updateText(this, value);\n\n    var observable = value;\n    updateText(this, observable.open(textBinding(this)));\n    return maybeUpdateBindings(this, name, observable);\n  }\n\n  function updateAttribute(el, name, conditional, value) {\n    if (conditional) {\n      if (value)\n        el.setAttribute(name, '');\n      else\n        el.removeAttribute(name);\n      return;\n    }\n\n    el.setAttribute(name, sanitizeValue(value));\n  }\n\n  function attributeBinding(el, name, conditional) {\n    return function(value) {\n      updateAttribute(el, name, conditional, value);\n    };\n  }\n\n  Element.prototype.bind = function(name, value, oneTime) {\n    var conditional = name[name.length - 1] == '?';\n    if (conditional) {\n      this.removeAttribute(name);\n      name = name.slice(0, -1);\n    }\n\n    if (oneTime)\n      return updateAttribute(this, name, conditional, value);\n\n\n    var observable = value;\n    updateAttribute(this, name, conditional,\n        observable.open(attributeBinding(this, name, conditional)));\n\n    return maybeUpdateBindings(this, name, observable);\n  };\n\n  var checkboxEventType;\n  (function() {\n    // Attempt to feature-detect which event (change or click) is fired first\n    // for checkboxes.\n    var div = document.createElement('div');\n    var checkbox = div.appendChild(document.createElement('input'));\n    checkbox.setAttribute('type', 'checkbox');\n    var first;\n    var count = 0;\n    checkbox.addEventListener('click', function(e) {\n      count++;\n      first = first || 'click';\n    });\n    checkbox.addEventListener('change', function() {\n      count++;\n      first = first || 'change';\n    });\n\n    var event = document.createEvent('MouseEvent');\n    event.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false,\n        false, false, false, 0, null);\n    checkbox.dispatchEvent(event);\n    // WebKit/Blink don't fire the change event if the element is outside the\n    // document, so assume 'change' for that case.\n    checkboxEventType = count == 1 ? 'change' : first;\n  })();\n\n  function getEventForInputType(element) {\n    switch (element.type) {\n      case 'checkbox':\n        return checkboxEventType;\n      case 'radio':\n      case 'select-multiple':\n      case 'select-one':\n        return 'change';\n      case 'range':\n        if (/Trident|MSIE/.test(navigator.userAgent))\n          return 'change';\n      default:\n        return 'input';\n    }\n  }\n\n  function updateInput(input, property, value, santizeFn) {\n    input[property] = (santizeFn || sanitizeValue)(value);\n  }\n\n  function inputBinding(input, property, santizeFn) {\n    return function(value) {\n      return updateInput(input, property, value, santizeFn);\n    }\n  }\n\n  function noop() {}\n\n  function bindInputEvent(input, property, observable, postEventFn) {\n    var eventType = getEventForInputType(input);\n\n    function eventHandler() {\n      observable.setValue(input[property]);\n      observable.discardChanges();\n      (postEventFn || noop)(input);\n      Platform.performMicrotaskCheckpoint();\n    }\n    input.addEventListener(eventType, eventHandler);\n\n    return {\n      close: function() {\n        input.removeEventListener(eventType, eventHandler);\n        observable.close();\n      },\n\n      observable_: observable\n    }\n  }\n\n  function booleanSanitize(value) {\n    return Boolean(value);\n  }\n\n  // |element| is assumed to be an HTMLInputElement with |type| == 'radio'.\n  // Returns an array containing all radio buttons other than |element| that\n  // have the same |name|, either in the form that |element| belongs to or,\n  // if no form, in the document tree to which |element| belongs.\n  //\n  // This implementation is based upon the HTML spec definition of a\n  // \"radio button group\":\n  //   http://www.whatwg.org/specs/web-apps/current-work/multipage/number-state.html#radio-button-group\n  //\n  function getAssociatedRadioButtons(element) {\n    if (element.form) {\n      return filter(element.form.elements, function(el) {\n        return el != element &&\n            el.tagName == 'INPUT' &&\n            el.type == 'radio' &&\n            el.name == element.name;\n      });\n    } else {\n      var treeScope = getTreeScope(element);\n      if (!treeScope)\n        return [];\n      var radios = treeScope.querySelectorAll(\n          'input[type=\"radio\"][name=\"' + element.name + '\"]');\n      return filter(radios, function(el) {\n        return el != element && !el.form;\n      });\n    }\n  }\n\n  function checkedPostEvent(input) {\n    // Only the radio button that is getting checked gets an event. We\n    // therefore find all the associated radio buttons and update their\n    // check binding manually.\n    if (input.tagName === 'INPUT' &&\n        input.type === 'radio') {\n      getAssociatedRadioButtons(input).forEach(function(radio) {\n        var checkedBinding = radio.bindings_.checked;\n        if (checkedBinding) {\n          // Set the value directly to avoid an infinite call stack.\n          checkedBinding.observable_.setValue(false);\n        }\n      });\n    }\n  }\n\n  HTMLInputElement.prototype.bind = function(name, value, oneTime) {\n    if (name !== 'value' && name !== 'checked')\n      return HTMLElement.prototype.bind.call(this, name, value, oneTime);\n\n    this.removeAttribute(name);\n    var sanitizeFn = name == 'checked' ? booleanSanitize : sanitizeValue;\n    var postEventFn = name == 'checked' ? checkedPostEvent : noop;\n\n    if (oneTime)\n      return updateInput(this, name, value, sanitizeFn);\n\n\n    var observable = value;\n    var binding = bindInputEvent(this, name, observable, postEventFn);\n    updateInput(this, name,\n                observable.open(inputBinding(this, name, sanitizeFn)),\n                sanitizeFn);\n\n    // Checkboxes may need to update bindings of other checkboxes.\n    return updateBindings(this, name, binding);\n  }\n\n  HTMLTextAreaElement.prototype.bind = function(name, value, oneTime) {\n    if (name !== 'value')\n      return HTMLElement.prototype.bind.call(this, name, value, oneTime);\n\n    this.removeAttribute('value');\n\n    if (oneTime)\n      return updateInput(this, 'value', value);\n\n    var observable = value;\n    var binding = bindInputEvent(this, 'value', observable);\n    updateInput(this, 'value',\n                observable.open(inputBinding(this, 'value', sanitizeValue)));\n    return maybeUpdateBindings(this, name, binding);\n  }\n\n  function updateOption(option, value) {\n    var parentNode = option.parentNode;;\n    var select;\n    var selectBinding;\n    var oldValue;\n    if (parentNode instanceof HTMLSelectElement &&\n        parentNode.bindings_ &&\n        parentNode.bindings_.value) {\n      select = parentNode;\n      selectBinding = select.bindings_.value;\n      oldValue = select.value;\n    }\n\n    option.value = sanitizeValue(value);\n\n    if (select && select.value != oldValue) {\n      selectBinding.observable_.setValue(select.value);\n      selectBinding.observable_.discardChanges();\n      Platform.performMicrotaskCheckpoint();\n    }\n  }\n\n  function optionBinding(option) {\n    return function(value) {\n      updateOption(option, value);\n    }\n  }\n\n  HTMLOptionElement.prototype.bind = function(name, value, oneTime) {\n    if (name !== 'value')\n      return HTMLElement.prototype.bind.call(this, name, value, oneTime);\n\n    this.removeAttribute('value');\n\n    if (oneTime)\n      return updateOption(this, value);\n\n    var observable = value;\n    var binding = bindInputEvent(this, 'value', observable);\n    updateOption(this, observable.open(optionBinding(this)));\n    return maybeUpdateBindings(this, name, binding);\n  }\n\n  HTMLSelectElement.prototype.bind = function(name, value, oneTime) {\n    if (name === 'selectedindex')\n      name = 'selectedIndex';\n\n    if (name !== 'selectedIndex' && name !== 'value')\n      return HTMLElement.prototype.bind.call(this, name, value, oneTime);\n\n    this.removeAttribute(name);\n\n    if (oneTime)\n      return updateInput(this, name, value);\n\n    var observable = value;\n    var binding = bindInputEvent(this, name, observable);\n    updateInput(this, name,\n                observable.open(inputBinding(this, name)));\n\n    // Option update events may need to access select bindings.\n    return updateBindings(this, name, binding);\n  }\n})(this);\n",
    "// Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n// This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n// The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n// The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n// Code distributed by Google as part of the polymer project is also\n// subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n\n(function(global) {\n  'use strict';\n\n  function assert(v) {\n    if (!v)\n      throw new Error('Assertion failed');\n  }\n\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n\n  function getFragmentRoot(node) {\n    var p;\n    while (p = node.parentNode) {\n      node = p;\n    }\n\n    return node;\n  }\n\n  function searchRefId(node, id) {\n    if (!id)\n      return;\n\n    var ref;\n    var selector = '#' + id;\n    while (!ref) {\n      node = getFragmentRoot(node);\n\n      if (node.protoContent_)\n        ref = node.protoContent_.querySelector(selector);\n      else if (node.getElementById)\n        ref = node.getElementById(id);\n\n      if (ref || !node.templateCreator_)\n        break\n\n      node = node.templateCreator_;\n    }\n\n    return ref;\n  }\n\n  function getInstanceRoot(node) {\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    return node.templateCreator_ ? node : null;\n  }\n\n  var Map;\n  if (global.Map && typeof global.Map.prototype.forEach === 'function') {\n    Map = global.Map;\n  } else {\n    Map = function() {\n      this.keys = [];\n      this.values = [];\n    };\n\n    Map.prototype = {\n      set: function(key, value) {\n        var index = this.keys.indexOf(key);\n        if (index < 0) {\n          this.keys.push(key);\n          this.values.push(value);\n        } else {\n          this.values[index] = value;\n        }\n      },\n\n      get: function(key) {\n        var index = this.keys.indexOf(key);\n        if (index < 0)\n          return;\n\n        return this.values[index];\n      },\n\n      delete: function(key, value) {\n        var index = this.keys.indexOf(key);\n        if (index < 0)\n          return false;\n\n        this.keys.splice(index, 1);\n        this.values.splice(index, 1);\n        return true;\n      },\n\n      forEach: function(f, opt_this) {\n        for (var i = 0; i < this.keys.length; i++)\n          f.call(opt_this || this, this.values[i], this.keys[i], this);\n      }\n    };\n  }\n\n  // JScript does not have __proto__. We wrap all object literals with\n  // createObject which uses Object.create, Object.defineProperty and\n  // Object.getOwnPropertyDescriptor to create a new object that does the exact\n  // same thing. The main downside to this solution is that we have to extract\n  // all those property descriptors for IE.\n  var createObject = ('__proto__' in {}) ?\n      function(obj) { return obj; } :\n      function(obj) {\n        var proto = obj.__proto__;\n        if (!proto)\n          return obj;\n        var newObject = Object.create(proto);\n        Object.getOwnPropertyNames(obj).forEach(function(name) {\n          Object.defineProperty(newObject, name,\n                               Object.getOwnPropertyDescriptor(obj, name));\n        });\n        return newObject;\n      };\n\n  // IE does not support have Document.prototype.contains.\n  if (typeof document.contains != 'function') {\n    Document.prototype.contains = function(node) {\n      if (node === this || node.parentNode === this)\n        return true;\n      return this.documentElement.contains(node);\n    }\n  }\n\n  var BIND = 'bind';\n  var REPEAT = 'repeat';\n  var IF = 'if';\n\n  var templateAttributeDirectives = {\n    'template': true,\n    'repeat': true,\n    'bind': true,\n    'ref': true\n  };\n\n  var semanticTemplateElements = {\n    'THEAD': true,\n    'TBODY': true,\n    'TFOOT': true,\n    'TH': true,\n    'TR': true,\n    'TD': true,\n    'COLGROUP': true,\n    'COL': true,\n    'CAPTION': true,\n    'OPTION': true,\n    'OPTGROUP': true\n  };\n\n  var hasTemplateElement = typeof HTMLTemplateElement !== 'undefined';\n  if (hasTemplateElement) {\n    // TODO(rafaelw): Remove when fix for\n    // https://codereview.chromium.org/164803002/\n    // makes it to Chrome release.\n    (function() {\n      var t = document.createElement('template');\n      var d = t.content.ownerDocument;\n      var html = d.appendChild(d.createElement('html'));\n      var head = html.appendChild(d.createElement('head'));\n      var base = d.createElement('base');\n      base.href = document.baseURI;\n      head.appendChild(base);\n    })();\n  }\n\n  var allTemplatesSelectors = 'template, ' +\n      Object.keys(semanticTemplateElements).map(function(tagName) {\n        return tagName.toLowerCase() + '[template]';\n      }).join(', ');\n\n  function isSVGTemplate(el) {\n    return el.tagName == 'template' &&\n           el.namespaceURI == 'http://www.w3.org/2000/svg';\n  }\n\n  function isHTMLTemplate(el) {\n    return el.tagName == 'TEMPLATE' &&\n           el.namespaceURI == 'http://www.w3.org/1999/xhtml';\n  }\n\n  function isAttributeTemplate(el) {\n    return Boolean(semanticTemplateElements[el.tagName] &&\n                   el.hasAttribute('template'));\n  }\n\n  function isTemplate(el) {\n    if (el.isTemplate_ === undefined)\n      el.isTemplate_ = el.tagName == 'TEMPLATE' || isAttributeTemplate(el);\n\n    return el.isTemplate_;\n  }\n\n  // FIXME: Observe templates being added/removed from documents\n  // FIXME: Expose imperative API to decorate and observe templates in\n  // \"disconnected tress\" (e.g. ShadowRoot)\n  document.addEventListener('DOMContentLoaded', function(e) {\n    bootstrapTemplatesRecursivelyFrom(document);\n    // FIXME: Is this needed? Seems like it shouldn't be.\n    Platform.performMicrotaskCheckpoint();\n  }, false);\n\n  function forAllTemplatesFrom(node, fn) {\n    var subTemplates = node.querySelectorAll(allTemplatesSelectors);\n\n    if (isTemplate(node))\n      fn(node)\n    forEach(subTemplates, fn);\n  }\n\n  function bootstrapTemplatesRecursivelyFrom(node) {\n    function bootstrap(template) {\n      if (!HTMLTemplateElement.decorate(template))\n        bootstrapTemplatesRecursivelyFrom(template.content);\n    }\n\n    forAllTemplatesFrom(node, bootstrap);\n  }\n\n  if (!hasTemplateElement) {\n    /**\n     * This represents a <template> element.\n     * @constructor\n     * @extends {HTMLElement}\n     */\n    global.HTMLTemplateElement = function() {\n      throw TypeError('Illegal constructor');\n    };\n  }\n\n  var hasProto = '__proto__' in {};\n\n  function mixin(to, from) {\n    Object.getOwnPropertyNames(from).forEach(function(name) {\n      Object.defineProperty(to, name,\n                            Object.getOwnPropertyDescriptor(from, name));\n    });\n  }\n\n  // http://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html#dfn-template-contents-owner\n  function getOrCreateTemplateContentsOwner(template) {\n    var doc = template.ownerDocument\n    if (!doc.defaultView)\n      return doc;\n    var d = doc.templateContentsOwner_;\n    if (!d) {\n      // TODO(arv): This should either be a Document or HTMLDocument depending\n      // on doc.\n      d = doc.implementation.createHTMLDocument('');\n      while (d.lastChild) {\n        d.removeChild(d.lastChild);\n      }\n      doc.templateContentsOwner_ = d;\n    }\n    return d;\n  }\n\n  function getTemplateStagingDocument(template) {\n    if (!template.stagingDocument_) {\n      var owner = template.ownerDocument;\n      if (!owner.stagingDocument_) {\n        owner.stagingDocument_ = owner.implementation.createHTMLDocument('');\n        owner.stagingDocument_.isStagingDocument = true;\n        // TODO(rafaelw): Remove when fix for\n        // https://codereview.chromium.org/164803002/\n        // makes it to Chrome release.\n        var base = owner.stagingDocument_.createElement('base');\n        base.href = document.baseURI;\n        owner.stagingDocument_.head.appendChild(base);\n\n        owner.stagingDocument_.stagingDocument_ = owner.stagingDocument_;\n      }\n\n      template.stagingDocument_ = owner.stagingDocument_;\n    }\n\n    return template.stagingDocument_;\n  }\n\n  // For non-template browsers, the parser will disallow <template> in certain\n  // locations, so we allow \"attribute templates\" which combine the template\n  // element with the top-level container node of the content, e.g.\n  //\n  //   <tr template repeat=\"{{ foo }}\"\" class=\"bar\"><td>Bar</td></tr>\n  //\n  // becomes\n  //\n  //   <template repeat=\"{{ foo }}\">\n  //   + #document-fragment\n  //     + <tr class=\"bar\">\n  //       + <td>Bar</td>\n  //\n  function extractTemplateFromAttributeTemplate(el) {\n    var template = el.ownerDocument.createElement('template');\n    el.parentNode.insertBefore(template, el);\n\n    var attribs = el.attributes;\n    var count = attribs.length;\n    while (count-- > 0) {\n      var attrib = attribs[count];\n      if (templateAttributeDirectives[attrib.name]) {\n        if (attrib.name !== 'template')\n          template.setAttribute(attrib.name, attrib.value);\n        el.removeAttribute(attrib.name);\n      }\n    }\n\n    return template;\n  }\n\n  function extractTemplateFromSVGTemplate(el) {\n    var template = el.ownerDocument.createElement('template');\n    el.parentNode.insertBefore(template, el);\n\n    var attribs = el.attributes;\n    var count = attribs.length;\n    while (count-- > 0) {\n      var attrib = attribs[count];\n      template.setAttribute(attrib.name, attrib.value);\n      el.removeAttribute(attrib.name);\n    }\n\n    el.parentNode.removeChild(el);\n    return template;\n  }\n\n  function liftNonNativeTemplateChildrenIntoContent(template, el, useRoot) {\n    var content = template.content;\n    if (useRoot) {\n      content.appendChild(el);\n      return;\n    }\n\n    var child;\n    while (child = el.firstChild) {\n      content.appendChild(child);\n    }\n  }\n\n  var templateObserver;\n  if (typeof MutationObserver == 'function') {\n    templateObserver = new MutationObserver(function(records) {\n      for (var i = 0; i < records.length; i++) {\n        records[i].target.refChanged_();\n      }\n    });\n  }\n\n  /**\n   * Ensures proper API and content model for template elements.\n   * @param {HTMLTemplateElement} opt_instanceRef The template element which\n   *     |el| template element will return as the value of its ref(), and whose\n   *     content will be used as source when createInstance() is invoked.\n   */\n  HTMLTemplateElement.decorate = function(el, opt_instanceRef) {\n    if (el.templateIsDecorated_)\n      return false;\n\n    var templateElement = el;\n    templateElement.templateIsDecorated_ = true;\n\n    var isNativeHTMLTemplate = isHTMLTemplate(templateElement) &&\n                               hasTemplateElement;\n    var bootstrapContents = isNativeHTMLTemplate;\n    var liftContents = !isNativeHTMLTemplate;\n    var liftRoot = false;\n\n    if (!isNativeHTMLTemplate) {\n      if (isAttributeTemplate(templateElement)) {\n        assert(!opt_instanceRef);\n        templateElement = extractTemplateFromAttributeTemplate(el);\n        templateElement.templateIsDecorated_ = true;\n        isNativeHTMLTemplate = hasTemplateElement;\n        liftRoot = true;\n      } else if (isSVGTemplate(templateElement)) {\n        templateElement = extractTemplateFromSVGTemplate(el);\n        templateElement.templateIsDecorated_ = true;\n        isNativeHTMLTemplate = hasTemplateElement;\n      }\n    }\n\n    if (!isNativeHTMLTemplate) {\n      fixTemplateElementPrototype(templateElement);\n      var doc = getOrCreateTemplateContentsOwner(templateElement);\n      templateElement.content_ = doc.createDocumentFragment();\n    }\n\n    if (opt_instanceRef) {\n      // template is contained within an instance, its direct content must be\n      // empty\n      templateElement.instanceRef_ = opt_instanceRef;\n    } else if (liftContents) {\n      liftNonNativeTemplateChildrenIntoContent(templateElement,\n                                               el,\n                                               liftRoot);\n    } else if (bootstrapContents) {\n      bootstrapTemplatesRecursivelyFrom(templateElement.content);\n    }\n\n    return true;\n  };\n\n  // TODO(rafaelw): This used to decorate recursively all templates from a given\n  // node. This happens by default on 'DOMContentLoaded', but may be needed\n  // in subtrees not descendent from document (e.g. ShadowRoot).\n  // Review whether this is the right public API.\n  HTMLTemplateElement.bootstrap = bootstrapTemplatesRecursivelyFrom;\n\n  var htmlElement = global.HTMLUnknownElement || HTMLElement;\n\n  var contentDescriptor = {\n    get: function() {\n      return this.content_;\n    },\n    enumerable: true,\n    configurable: true\n  };\n\n  if (!hasTemplateElement) {\n    // Gecko is more picky with the prototype than WebKit. Make sure to use the\n    // same prototype as created in the constructor.\n    HTMLTemplateElement.prototype = Object.create(htmlElement.prototype);\n\n    Object.defineProperty(HTMLTemplateElement.prototype, 'content',\n                          contentDescriptor);\n  }\n\n  function fixTemplateElementPrototype(el) {\n    if (hasProto)\n      el.__proto__ = HTMLTemplateElement.prototype;\n    else\n      mixin(el, HTMLTemplateElement.prototype);\n  }\n\n  function ensureSetModelScheduled(template) {\n    if (!template.setModelFn_) {\n      template.setModelFn_ = function() {\n        template.setModelFnScheduled_ = false;\n        var map = getBindings(template,\n            template.delegate_ && template.delegate_.prepareBinding);\n        processBindings(template, map, template.model_);\n      };\n    }\n\n    if (!template.setModelFnScheduled_) {\n      template.setModelFnScheduled_ = true;\n      Observer.runEOM_(template.setModelFn_);\n    }\n  }\n\n  mixin(HTMLTemplateElement.prototype, {\n    bind: function(name, value, oneTime) {\n      if (name != 'ref')\n        return Element.prototype.bind.call(this, name, value, oneTime);\n\n      var self = this;\n      var ref = oneTime ? value : value.open(function(ref) {\n        self.setAttribute('ref', ref);\n        self.refChanged_();\n      });\n\n      this.setAttribute('ref', ref);\n      this.refChanged_();\n      if (oneTime)\n        return;\n\n      if (!this.bindings_) {\n        this.bindings_ = { ref: value };\n      } else {\n        this.bindings_.ref = value;\n      }\n\n      return value;\n    },\n\n    processBindingDirectives_: function(directives) {\n      if (this.iterator_)\n        this.iterator_.closeDeps();\n\n      if (!directives.if && !directives.bind && !directives.repeat) {\n        if (this.iterator_) {\n          this.iterator_.close();\n          this.iterator_ = undefined;\n        }\n\n        return;\n      }\n\n      if (!this.iterator_) {\n        this.iterator_ = new TemplateIterator(this);\n      }\n\n      this.iterator_.updateDependencies(directives, this.model_);\n\n      if (templateObserver) {\n        templateObserver.observe(this, { attributes: true,\n                                         attributeFilter: ['ref'] });\n      }\n\n      return this.iterator_;\n    },\n\n    createInstance: function(model, bindingDelegate, delegate_) {\n      if (bindingDelegate)\n        delegate_ = this.newDelegate_(bindingDelegate);\n      else if (!delegate_)\n        delegate_ = this.delegate_;\n\n      if (!this.refContent_)\n        this.refContent_ = this.ref_.content;\n      var content = this.refContent_;\n      if (content.firstChild === null)\n        return emptyInstance;\n\n      var map = getInstanceBindingMap(content, delegate_);\n      var stagingDocument = getTemplateStagingDocument(this);\n      var instance = stagingDocument.createDocumentFragment();\n      instance.templateCreator_ = this;\n      instance.protoContent_ = content;\n      instance.bindings_ = [];\n      instance.terminator_ = null;\n      var instanceRecord = instance.templateInstance_ = {\n        firstNode: null,\n        lastNode: null,\n        model: model\n      };\n\n      var i = 0;\n      var collectTerminator = false;\n      for (var child = content.firstChild; child; child = child.nextSibling) {\n        // The terminator of the instance is the clone of the last child of the\n        // content. If the last child is an active template, it may produce\n        // instances as a result of production, so simply collecting the last\n        // child of the instance after it has finished producing may be wrong.\n        if (child.nextSibling === null)\n          collectTerminator = true;\n\n        var clone = cloneAndBindInstance(child, instance, stagingDocument,\n                                         map.children[i++],\n                                         model,\n                                         delegate_,\n                                         instance.bindings_);\n        clone.templateInstance_ = instanceRecord;\n        if (collectTerminator)\n          instance.terminator_ = clone;\n      }\n\n      instanceRecord.firstNode = instance.firstChild;\n      instanceRecord.lastNode = instance.lastChild;\n      instance.templateCreator_ = undefined;\n      instance.protoContent_ = undefined;\n      return instance;\n    },\n\n    get model() {\n      return this.model_;\n    },\n\n    set model(model) {\n      this.model_ = model;\n      ensureSetModelScheduled(this);\n    },\n\n    get bindingDelegate() {\n      return this.delegate_ && this.delegate_.raw;\n    },\n\n    refChanged_: function() {\n      if (!this.iterator_ || this.refContent_ === this.ref_.content)\n        return;\n\n      this.refContent_ = undefined;\n      this.iterator_.valueChanged();\n      this.iterator_.updateIteratedValue(this.iterator_.getUpdatedValue());\n    },\n\n    clear: function() {\n      this.model_ = undefined;\n      this.delegate_ = undefined;\n      if (this.bindings_ && this.bindings_.ref)\n        this.bindings_.ref.close()\n      this.refContent_ = undefined;\n      if (!this.iterator_)\n        return;\n      this.iterator_.valueChanged();\n      this.iterator_.close()\n      this.iterator_ = undefined;\n    },\n\n    setDelegate_: function(delegate) {\n      this.delegate_ = delegate;\n      this.bindingMap_ = undefined;\n      if (this.iterator_) {\n        this.iterator_.instancePositionChangedFn_ = undefined;\n        this.iterator_.instanceModelFn_ = undefined;\n      }\n    },\n\n    newDelegate_: function(bindingDelegate) {\n      if (!bindingDelegate)\n        return;\n\n      function delegateFn(name) {\n        var fn = bindingDelegate && bindingDelegate[name];\n        if (typeof fn != 'function')\n          return;\n\n        return function() {\n          return fn.apply(bindingDelegate, arguments);\n        };\n      }\n\n      return {\n        bindingMaps: {},\n        raw: bindingDelegate,\n        prepareBinding: delegateFn('prepareBinding'),\n        prepareInstanceModel: delegateFn('prepareInstanceModel'),\n        prepareInstancePositionChanged:\n            delegateFn('prepareInstancePositionChanged')\n      };\n    },\n\n    set bindingDelegate(bindingDelegate) {\n      if (this.delegate_) {\n        throw Error('Template must be cleared before a new bindingDelegate ' +\n                    'can be assigned');\n      }\n\n      this.setDelegate_(this.newDelegate_(bindingDelegate));\n    },\n\n    get ref_() {\n      var ref = searchRefId(this, this.getAttribute('ref'));\n      if (!ref)\n        ref = this.instanceRef_;\n\n      if (!ref)\n        return this;\n\n      var nextRef = ref.ref_;\n      return nextRef ? nextRef : ref;\n    }\n  });\n\n  // Returns\n  //   a) undefined if there are no mustaches.\n  //   b) [TEXT, (ONE_TIME?, PATH, DELEGATE_FN, TEXT)+] if there is at least one mustache.\n  function parseMustaches(s, name, node, prepareBindingFn) {\n    if (!s || !s.length)\n      return;\n\n    var tokens;\n    var length = s.length;\n    var startIndex = 0, lastIndex = 0, endIndex = 0;\n    var onlyOneTime = true;\n    while (lastIndex < length) {\n      var startIndex = s.indexOf('{{', lastIndex);\n      var oneTimeStart = s.indexOf('[[', lastIndex);\n      var oneTime = false;\n      var terminator = '}}';\n\n      if (oneTimeStart >= 0 &&\n          (startIndex < 0 || oneTimeStart < startIndex)) {\n        startIndex = oneTimeStart;\n        oneTime = true;\n        terminator = ']]';\n      }\n\n      endIndex = startIndex < 0 ? -1 : s.indexOf(terminator, startIndex + 2);\n\n      if (endIndex < 0) {\n        if (!tokens)\n          return;\n\n        tokens.push(s.slice(lastIndex)); // TEXT\n        break;\n      }\n\n      tokens = tokens || [];\n      tokens.push(s.slice(lastIndex, startIndex)); // TEXT\n      var pathString = s.slice(startIndex + 2, endIndex).trim();\n      tokens.push(oneTime); // ONE_TIME?\n      onlyOneTime = onlyOneTime && oneTime;\n      var delegateFn = prepareBindingFn &&\n                       prepareBindingFn(pathString, name, node);\n      // Don't try to parse the expression if there's a prepareBinding function\n      if (delegateFn == null) {\n        tokens.push(Path.get(pathString)); // PATH\n      } else {\n        tokens.push(null);\n      }\n      tokens.push(delegateFn); // DELEGATE_FN\n      lastIndex = endIndex + 2;\n    }\n\n    if (lastIndex === length)\n      tokens.push(''); // TEXT\n\n    tokens.hasOnePath = tokens.length === 5;\n    tokens.isSimplePath = tokens.hasOnePath &&\n                          tokens[0] == '' &&\n                          tokens[4] == '';\n    tokens.onlyOneTime = onlyOneTime;\n\n    tokens.combinator = function(values) {\n      var newValue = tokens[0];\n\n      for (var i = 1; i < tokens.length; i += 4) {\n        var value = tokens.hasOnePath ? values : values[(i - 1) / 4];\n        if (value !== undefined)\n          newValue += value;\n        newValue += tokens[i + 3];\n      }\n\n      return newValue;\n    }\n\n    return tokens;\n  };\n\n  function processOneTimeBinding(name, tokens, node, model) {\n    if (tokens.hasOnePath) {\n      var delegateFn = tokens[3];\n      var value = delegateFn ? delegateFn(model, node, true) :\n                               tokens[2].getValueFrom(model);\n      return tokens.isSimplePath ? value : tokens.combinator(value);\n    }\n\n    var values = [];\n    for (var i = 1; i < tokens.length; i += 4) {\n      var delegateFn = tokens[i + 2];\n      values[(i - 1) / 4] = delegateFn ? delegateFn(model, node) :\n          tokens[i + 1].getValueFrom(model);\n    }\n\n    return tokens.combinator(values);\n  }\n\n  function processSinglePathBinding(name, tokens, node, model) {\n    var delegateFn = tokens[3];\n    var observer = delegateFn ? delegateFn(model, node, false) :\n        new PathObserver(model, tokens[2]);\n\n    return tokens.isSimplePath ? observer :\n        new ObserverTransform(observer, tokens.combinator);\n  }\n\n  function processBinding(name, tokens, node, model) {\n    if (tokens.onlyOneTime)\n      return processOneTimeBinding(name, tokens, node, model);\n\n    if (tokens.hasOnePath)\n      return processSinglePathBinding(name, tokens, node, model);\n\n    var observer = new CompoundObserver();\n\n    for (var i = 1; i < tokens.length; i += 4) {\n      var oneTime = tokens[i];\n      var delegateFn = tokens[i + 2];\n\n      if (delegateFn) {\n        var value = delegateFn(model, node, oneTime);\n        if (oneTime)\n          observer.addPath(value)\n        else\n          observer.addObserver(value);\n        continue;\n      }\n\n      var path = tokens[i + 1];\n      if (oneTime)\n        observer.addPath(path.getValueFrom(model))\n      else\n        observer.addPath(model, path);\n    }\n\n    return new ObserverTransform(observer, tokens.combinator);\n  }\n\n  function processBindings(node, bindings, model, instanceBindings) {\n    for (var i = 0; i < bindings.length; i += 2) {\n      var name = bindings[i]\n      var tokens = bindings[i + 1];\n      var value = processBinding(name, tokens, node, model);\n      var binding = node.bind(name, value, tokens.onlyOneTime);\n      if (binding && instanceBindings)\n        instanceBindings.push(binding);\n    }\n\n    node.bindFinished();\n    if (!bindings.isTemplate)\n      return;\n\n    node.model_ = model;\n    var iter = node.processBindingDirectives_(bindings);\n    if (instanceBindings && iter)\n      instanceBindings.push(iter);\n  }\n\n  function parseWithDefault(el, name, prepareBindingFn) {\n    var v = el.getAttribute(name);\n    return parseMustaches(v == '' ? '{{}}' : v, name, el, prepareBindingFn);\n  }\n\n  function parseAttributeBindings(element, prepareBindingFn) {\n    assert(element);\n\n    var bindings = [];\n    var ifFound = false;\n    var bindFound = false;\n\n    for (var i = 0; i < element.attributes.length; i++) {\n      var attr = element.attributes[i];\n      var name = attr.name;\n      var value = attr.value;\n\n      // Allow bindings expressed in attributes to be prefixed with underbars.\n      // We do this to allow correct semantics for browsers that don't implement\n      // <template> where certain attributes might trigger side-effects -- and\n      // for IE which sanitizes certain attributes, disallowing mustache\n      // replacements in their text.\n      while (name[0] === '_') {\n        name = name.substring(1);\n      }\n\n      if (isTemplate(element) &&\n          (name === IF || name === BIND || name === REPEAT)) {\n        continue;\n      }\n\n      var tokens = parseMustaches(value, name, element,\n                                  prepareBindingFn);\n      if (!tokens)\n        continue;\n\n      bindings.push(name, tokens);\n    }\n\n    if (isTemplate(element)) {\n      bindings.isTemplate = true;\n      bindings.if = parseWithDefault(element, IF, prepareBindingFn);\n      bindings.bind = parseWithDefault(element, BIND, prepareBindingFn);\n      bindings.repeat = parseWithDefault(element, REPEAT, prepareBindingFn);\n\n      if (bindings.if && !bindings.bind && !bindings.repeat)\n        bindings.bind = parseMustaches('{{}}', BIND, element, prepareBindingFn);\n    }\n\n    return bindings;\n  }\n\n  function getBindings(node, prepareBindingFn) {\n    if (node.nodeType === Node.ELEMENT_NODE)\n      return parseAttributeBindings(node, prepareBindingFn);\n\n    if (node.nodeType === Node.TEXT_NODE) {\n      var tokens = parseMustaches(node.data, 'textContent', node,\n                                  prepareBindingFn);\n      if (tokens)\n        return ['textContent', tokens];\n    }\n\n    return [];\n  }\n\n  function cloneAndBindInstance(node, parent, stagingDocument, bindings, model,\n                                delegate,\n                                instanceBindings,\n                                instanceRecord) {\n    var clone = parent.appendChild(stagingDocument.importNode(node, false));\n\n    var i = 0;\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      cloneAndBindInstance(child, clone, stagingDocument,\n                            bindings.children[i++],\n                            model,\n                            delegate,\n                            instanceBindings);\n    }\n\n    if (bindings.isTemplate) {\n      HTMLTemplateElement.decorate(clone, node);\n      if (delegate)\n        clone.setDelegate_(delegate);\n    }\n\n    processBindings(clone, bindings, model, instanceBindings);\n    return clone;\n  }\n\n  function createInstanceBindingMap(node, prepareBindingFn) {\n    var map = getBindings(node, prepareBindingFn);\n    map.children = {};\n    var index = 0;\n    for (var child = node.firstChild; child; child = child.nextSibling) {\n      map.children[index++] = createInstanceBindingMap(child, prepareBindingFn);\n    }\n\n    return map;\n  }\n\n  var contentUidCounter = 1;\n\n  // TODO(rafaelw): Setup a MutationObserver on content which clears the id\n  // so that bindingMaps regenerate when the template.content changes.\n  function getContentUid(content) {\n    var id = content.id_;\n    if (!id)\n      id = content.id_ = contentUidCounter++;\n    return id;\n  }\n\n  // Each delegate is associated with a set of bindingMaps, one for each\n  // content which may be used by a template. The intent is that each binding\n  // delegate gets the opportunity to prepare the instance (via the prepare*\n  // delegate calls) once across all uses.\n  // TODO(rafaelw): Separate out the parse map from the binding map. In the\n  // current implementation, if two delegates need a binding map for the same\n  // content, the second will have to reparse.\n  function getInstanceBindingMap(content, delegate_) {\n    var contentId = getContentUid(content);\n    if (delegate_) {\n      var map = delegate_.bindingMaps[contentId];\n      if (!map) {\n        map = delegate_.bindingMaps[contentId] =\n            createInstanceBindingMap(content, delegate_.prepareBinding) || [];\n      }\n      return map;\n    }\n\n    var map = content.bindingMap_;\n    if (!map) {\n      map = content.bindingMap_ =\n          createInstanceBindingMap(content, undefined) || [];\n    }\n    return map;\n  }\n\n  Object.defineProperty(Node.prototype, 'templateInstance', {\n    get: function() {\n      var instance = this.templateInstance_;\n      return instance ? instance :\n          (this.parentNode ? this.parentNode.templateInstance : undefined);\n    }\n  });\n\n  var emptyInstance = document.createDocumentFragment();\n  emptyInstance.bindings_ = [];\n  emptyInstance.terminator_ = null;\n\n  function TemplateIterator(templateElement) {\n    this.closed = false;\n    this.templateElement_ = templateElement;\n    this.instances = [];\n    this.deps = undefined;\n    this.iteratedValue = [];\n    this.presentValue = undefined;\n    this.arrayObserver = undefined;\n  }\n\n  TemplateIterator.prototype = {\n    closeDeps: function() {\n      var deps = this.deps;\n      if (deps) {\n        if (deps.ifOneTime === false)\n          deps.ifValue.close();\n        if (deps.oneTime === false)\n          deps.value.close();\n      }\n    },\n\n    updateDependencies: function(directives, model) {\n      this.closeDeps();\n\n      var deps = this.deps = {};\n      var template = this.templateElement_;\n\n      var ifValue = true;\n      if (directives.if) {\n        deps.hasIf = true;\n        deps.ifOneTime = directives.if.onlyOneTime;\n        deps.ifValue = processBinding(IF, directives.if, template, model);\n\n        ifValue = deps.ifValue;\n\n        // oneTime if & predicate is false. nothing else to do.\n        if (deps.ifOneTime && !ifValue) {\n          this.valueChanged();\n          return;\n        }\n\n        if (!deps.ifOneTime)\n          ifValue = ifValue.open(this.updateIfValue, this);\n      }\n\n      if (directives.repeat) {\n        deps.repeat = true;\n        deps.oneTime = directives.repeat.onlyOneTime;\n        deps.value = processBinding(REPEAT, directives.repeat, template, model);\n      } else {\n        deps.repeat = false;\n        deps.oneTime = directives.bind.onlyOneTime;\n        deps.value = processBinding(BIND, directives.bind, template, model);\n      }\n\n      var value = deps.value;\n      if (!deps.oneTime)\n        value = value.open(this.updateIteratedValue, this);\n\n      if (!ifValue) {\n        this.valueChanged();\n        return;\n      }\n\n      this.updateValue(value);\n    },\n\n    /**\n     * Gets the updated value of the bind/repeat. This can potentially call\n     * user code (if a bindingDelegate is set up) so we try to avoid it if we\n     * already have the value in hand (from Observer.open).\n     */\n    getUpdatedValue: function() {\n      var value = this.deps.value;\n      if (!this.deps.oneTime)\n        value = value.discardChanges();\n      return value;\n    },\n\n    updateIfValue: function(ifValue) {\n      if (!ifValue) {\n        this.valueChanged();\n        return;\n      }\n\n      this.updateValue(this.getUpdatedValue());\n    },\n\n    updateIteratedValue: function(value) {\n      if (this.deps.hasIf) {\n        var ifValue = this.deps.ifValue;\n        if (!this.deps.ifOneTime)\n          ifValue = ifValue.discardChanges();\n        if (!ifValue) {\n          this.valueChanged();\n          return;\n        }\n      }\n\n      this.updateValue(value);\n    },\n\n    updateValue: function(value) {\n      if (!this.deps.repeat)\n        value = [value];\n      var observe = this.deps.repeat &&\n                    !this.deps.oneTime &&\n                    Array.isArray(value);\n      this.valueChanged(value, observe);\n    },\n\n    valueChanged: function(value, observeValue) {\n      if (!Array.isArray(value))\n        value = [];\n\n      if (value === this.iteratedValue)\n        return;\n\n      this.unobserve();\n      this.presentValue = value;\n      if (observeValue) {\n        this.arrayObserver = new ArrayObserver(this.presentValue);\n        this.arrayObserver.open(this.handleSplices, this);\n      }\n\n      this.handleSplices(ArrayObserver.calculateSplices(this.presentValue,\n                                                        this.iteratedValue));\n    },\n\n    getLastInstanceNode: function(index) {\n      if (index == -1)\n        return this.templateElement_;\n      var instance = this.instances[index];\n      var terminator = instance.terminator_;\n      if (!terminator)\n        return this.getLastInstanceNode(index - 1);\n\n      if (terminator.nodeType !== Node.ELEMENT_NODE ||\n          this.templateElement_ === terminator) {\n        return terminator;\n      }\n\n      var subtemplateIterator = terminator.iterator_;\n      if (!subtemplateIterator)\n        return terminator;\n\n      return subtemplateIterator.getLastTemplateNode();\n    },\n\n    getLastTemplateNode: function() {\n      return this.getLastInstanceNode(this.instances.length - 1);\n    },\n\n    insertInstanceAt: function(index, fragment) {\n      var previousInstanceLast = this.getLastInstanceNode(index - 1);\n      var parent = this.templateElement_.parentNode;\n      this.instances.splice(index, 0, fragment);\n\n      parent.insertBefore(fragment, previousInstanceLast.nextSibling);\n    },\n\n    extractInstanceAt: function(index) {\n      var previousInstanceLast = this.getLastInstanceNode(index - 1);\n      var lastNode = this.getLastInstanceNode(index);\n      var parent = this.templateElement_.parentNode;\n      var instance = this.instances.splice(index, 1)[0];\n\n      while (lastNode !== previousInstanceLast) {\n        var node = previousInstanceLast.nextSibling;\n        if (node == lastNode)\n          lastNode = previousInstanceLast;\n\n        instance.appendChild(parent.removeChild(node));\n      }\n\n      return instance;\n    },\n\n    getDelegateFn: function(fn) {\n      fn = fn && fn(this.templateElement_);\n      return typeof fn === 'function' ? fn : null;\n    },\n\n    handleSplices: function(splices) {\n      if (this.closed || !splices.length)\n        return;\n\n      var template = this.templateElement_;\n\n      if (!template.parentNode) {\n        this.close();\n        return;\n      }\n\n      ArrayObserver.applySplices(this.iteratedValue, this.presentValue,\n                                 splices);\n\n      var delegate = template.delegate_;\n      if (this.instanceModelFn_ === undefined) {\n        this.instanceModelFn_ =\n            this.getDelegateFn(delegate && delegate.prepareInstanceModel);\n      }\n\n      if (this.instancePositionChangedFn_ === undefined) {\n        this.instancePositionChangedFn_ =\n            this.getDelegateFn(delegate &&\n                               delegate.prepareInstancePositionChanged);\n      }\n\n      // Instance Removals\n      var instanceCache = new Map;\n      var removeDelta = 0;\n      for (var i = 0; i < splices.length; i++) {\n        var splice = splices[i];\n        var removed = splice.removed;\n        for (var j = 0; j < removed.length; j++) {\n          var model = removed[j];\n          var instance = this.extractInstanceAt(splice.index + removeDelta);\n          if (instance !== emptyInstance) {\n            instanceCache.set(model, instance);\n          }\n        }\n\n        removeDelta -= splice.addedCount;\n      }\n\n      // Instance Insertions\n      for (var i = 0; i < splices.length; i++) {\n        var splice = splices[i];\n        var addIndex = splice.index;\n        for (; addIndex < splice.index + splice.addedCount; addIndex++) {\n          var model = this.iteratedValue[addIndex];\n          var instance = instanceCache.get(model);\n          if (instance) {\n            instanceCache.delete(model);\n          } else {\n            if (this.instanceModelFn_) {\n              model = this.instanceModelFn_(model);\n            }\n\n            if (model === undefined) {\n              instance = emptyInstance;\n            } else {\n              instance = template.createInstance(model, undefined, delegate);\n            }\n          }\n\n          this.insertInstanceAt(addIndex, instance);\n        }\n      }\n\n      instanceCache.forEach(function(instance) {\n        this.closeInstanceBindings(instance);\n      }, this);\n\n      if (this.instancePositionChangedFn_)\n        this.reportInstancesMoved(splices);\n    },\n\n    reportInstanceMoved: function(index) {\n      var instance = this.instances[index];\n      if (instance === emptyInstance)\n        return;\n\n      this.instancePositionChangedFn_(instance.templateInstance_, index);\n    },\n\n    reportInstancesMoved: function(splices) {\n      var index = 0;\n      var offset = 0;\n      for (var i = 0; i < splices.length; i++) {\n        var splice = splices[i];\n        if (offset != 0) {\n          while (index < splice.index) {\n            this.reportInstanceMoved(index);\n            index++;\n          }\n        } else {\n          index = splice.index;\n        }\n\n        while (index < splice.index + splice.addedCount) {\n          this.reportInstanceMoved(index);\n          index++;\n        }\n\n        offset += splice.addedCount - splice.removed.length;\n      }\n\n      if (offset == 0)\n        return;\n\n      var length = this.instances.length;\n      while (index < length) {\n        this.reportInstanceMoved(index);\n        index++;\n      }\n    },\n\n    closeInstanceBindings: function(instance) {\n      var bindings = instance.bindings_;\n      for (var i = 0; i < bindings.length; i++) {\n        bindings[i].close();\n      }\n    },\n\n    unobserve: function() {\n      if (!this.arrayObserver)\n        return;\n\n      this.arrayObserver.close();\n      this.arrayObserver = undefined;\n    },\n\n    close: function() {\n      if (this.closed)\n        return;\n      this.unobserve();\n      for (var i = 0; i < this.instances.length; i++) {\n        this.closeInstanceBindings(this.instances[i]);\n      }\n\n      this.instances.length = 0;\n      this.closeDeps();\n      this.templateElement_.iterator_ = undefined;\n      this.closed = true;\n    }\n  };\n\n  // Polyfill-specific API.\n  HTMLTemplateElement.forAllTemplatesFrom_ = forAllTemplatesFrom;\n})(this);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\nvar iterations = 0;\nvar callbacks = [];\nvar twiddle = document.createTextNode('');\n\nfunction endOfMicrotask(callback) {\n  twiddle.textContent = iterations++;\n  callbacks.push(callback);\n}\n\nfunction atEndOfMicrotask() {\n  while (callbacks.length) {\n    callbacks.shift()();\n  }\n}\n\nnew (window.MutationObserver || JsMutationObserver)(atEndOfMicrotask)\n  .observe(twiddle, {characterData: true})\n  ;\n\n// exports\n\nscope.endOfMicrotask = endOfMicrotask;\n\n})(Platform);\n\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n// inject style sheet\nvar style = document.createElement('style');\nstyle.textContent = 'template {display: none !important;} /* injected by platform.js */';\nvar head = document.querySelector('head');\nhead.insertBefore(style, head.firstChild);\n\n// flush (with logging)\nvar flushing;\nfunction flush() {\n  if (!flushing) {\n    flushing = true;\n    scope.endOfMicrotask(function() {\n      flushing = false;\n      logFlags.data && console.group('Platform.flush()');\n      scope.performMicrotaskCheckpoint();\n      logFlags.data && console.groupEnd();\n    });\n  }\n};\n\n// polling dirty checker\n// flush periodically if platform does not have object observe.\nif (!Observer.hasObjectObserve) {\n  var FLUSH_POLL_INTERVAL = 125;\n  window.addEventListener('WebComponentsReady', function() {\n    flush();\n    scope.flushPoll = setInterval(flush, FLUSH_POLL_INTERVAL);\n  });\n} else {\n  // make flush a no-op when we have Object.observe\n  flush = function() {};\n}\n\nif (window.CustomElements && !CustomElements.useNative) {\n  var originalImportNode = Document.prototype.importNode;\n  Document.prototype.importNode = function(node, deep) {\n    var imported = originalImportNode.call(this, node, deep);\n    CustomElements.upgradeAll(imported);\n    return imported;\n  }\n}\n\n// exports\nscope.flush = flush;\n\n})(window.Platform);\n\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\nvar urlResolver = {\n  resolveDom: function(root, url) {\n    url = url || root.ownerDocument.baseURI;\n    this.resolveAttributes(root, url);\n    this.resolveStyles(root, url);\n    // handle template.content\n    var templates = root.querySelectorAll('template');\n    if (templates) {\n      for (var i = 0, l = templates.length, t; (i < l) && (t = templates[i]); i++) {\n        if (t.content) {\n          this.resolveDom(t.content, url);\n        }\n      }\n    }\n  },\n  resolveTemplate: function(template) {\n    this.resolveDom(template.content, template.ownerDocument.baseURI);\n  },\n  resolveStyles: function(root, url) {\n    var styles = root.querySelectorAll('style');\n    if (styles) {\n      for (var i = 0, l = styles.length, s; (i < l) && (s = styles[i]); i++) {\n        this.resolveStyle(s, url);\n      }\n    }\n  },\n  resolveStyle: function(style, url) {\n    url = url || style.ownerDocument.baseURI;\n    style.textContent = this.resolveCssText(style.textContent, url);\n  },\n  resolveCssText: function(cssText, baseUrl, keepAbsolute) {\n    cssText = replaceUrlsInCssText(cssText, baseUrl, keepAbsolute, CSS_URL_REGEXP);\n    return replaceUrlsInCssText(cssText, baseUrl, keepAbsolute, CSS_IMPORT_REGEXP);\n  },\n  resolveAttributes: function(root, url) {\n    if (root.hasAttributes && root.hasAttributes()) {\n      this.resolveElementAttributes(root, url);\n    }\n    // search for attributes that host urls\n    var nodes = root && root.querySelectorAll(URL_ATTRS_SELECTOR);\n    if (nodes) {\n      for (var i = 0, l = nodes.length, n; (i < l) && (n = nodes[i]); i++) {\n        this.resolveElementAttributes(n, url);\n      }\n    }\n  },\n  resolveElementAttributes: function(node, url) {\n    url = url || node.ownerDocument.baseURI;\n    URL_ATTRS.forEach(function(v) {\n      var attr = node.attributes[v];\n      var value = attr && attr.value;\n      var replacement;\n      if (value && value.search(URL_TEMPLATE_SEARCH) < 0) {\n        if (v === 'style') {\n          replacement = replaceUrlsInCssText(value, url, false, CSS_URL_REGEXP);\n        } else {\n          replacement = resolveRelativeUrl(url, value);\n        }\n        attr.value = replacement;\n      }\n    });\n  }\n};\n\nvar CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\nvar CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\nvar URL_ATTRS = ['href', 'src', 'action', 'style', 'url'];\nvar URL_ATTRS_SELECTOR = '[' + URL_ATTRS.join('],[') + ']';\nvar URL_TEMPLATE_SEARCH = '{{.*}}';\n\nfunction replaceUrlsInCssText(cssText, baseUrl, keepAbsolute, regexp) {\n  return cssText.replace(regexp, function(m, pre, url, post) {\n    var urlPath = url.replace(/[\"']/g, '');\n    urlPath = resolveRelativeUrl(baseUrl, urlPath, keepAbsolute);\n    return pre + '\\'' + urlPath + '\\'' + post;\n  });\n}\n\nfunction resolveRelativeUrl(baseUrl, url, keepAbsolute) {\n  // do not resolve '/' absolute urls\n  if (url && url[0] === '/') {\n    return url;\n  }\n  var u = new URL(url, baseUrl);\n  return keepAbsolute ? u.href : makeDocumentRelPath(u.href);\n}\n\nfunction makeDocumentRelPath(url) {\n  var root = new URL(document.baseURI);\n  var u = new URL(url, root);\n  if (u.host === root.host && u.port === root.port &&\n      u.protocol === root.protocol) {\n    return makeRelPath(root, u);\n  } else {\n    return url;\n  }\n}\n\n// make a relative path from source to target\nfunction makeRelPath(sourceUrl, targetUrl) {\n  var source = sourceUrl.pathname;\n  var target = targetUrl.pathname;\n  var s = source.split('/');\n  var t = target.split('/');\n  while (s.length && s[0] === t[0]){\n    s.shift();\n    t.shift();\n  }\n  for (var i = 0, l = s.length - 1; i < l; i++) {\n    t.unshift('..');\n  }\n  return t.join('/') + targetUrl.search + targetUrl.hash;\n}\n\n// exports\nscope.urlResolver = urlResolver;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n  var endOfMicrotask = Platform.endOfMicrotask;\n\n  // Generic url loader\n  function Loader(regex) {\n    this.cache = Object.create(null);\n    this.map = Object.create(null);\n    this.requests = 0;\n    this.regex = regex;\n  }\n  Loader.prototype = {\n\n    // TODO(dfreedm): there may be a better factoring here\n    // extract absolute urls from the text (full of relative urls)\n    extractUrls: function(text, base) {\n      var matches = [];\n      var matched, u;\n      while ((matched = this.regex.exec(text))) {\n        u = new URL(matched[1], base);\n        matches.push({matched: matched[0], url: u.href});\n      }\n      return matches;\n    },\n    // take a text blob, a root url, and a callback and load all the urls found within the text\n    // returns a map of absolute url to text\n    process: function(text, root, callback) {\n      var matches = this.extractUrls(text, root);\n\n      // every call to process returns all the text this loader has ever received\n      var done = callback.bind(null, this.map);\n      this.fetch(matches, done);\n    },\n    // build a mapping of url -> text from matches\n    fetch: function(matches, callback) {\n      var inflight = matches.length;\n\n      // return early if there is no fetching to be done\n      if (!inflight) {\n        return callback();\n      }\n\n      // wait for all subrequests to return\n      var done = function() {\n        if (--inflight === 0) {\n          callback();\n        }\n      };\n\n      // start fetching all subrequests\n      var m, req, url;\n      for (var i = 0; i < inflight; i++) {\n        m = matches[i];\n        url = m.url;\n        req = this.cache[url];\n        // if this url has already been requested, skip requesting it again\n        if (!req) {\n          req = this.xhr(url);\n          req.match = m;\n          this.cache[url] = req;\n        }\n        // wait for the request to process its subrequests\n        req.wait(done);\n      }\n    },\n    handleXhr: function(request) {\n      var match = request.match;\n      var url = match.url;\n\n      // handle errors with an empty string\n      var response = request.response || request.responseText || '';\n      this.map[url] = response;\n      this.fetch(this.extractUrls(response, url), request.resolve);\n    },\n    xhr: function(url) {\n      this.requests++;\n      var request = new XMLHttpRequest();\n      request.open('GET', url, true);\n      request.send();\n      request.onerror = request.onload = this.handleXhr.bind(this, request);\n\n      // queue of tasks to run after XHR returns\n      request.pending = [];\n      request.resolve = function() {\n        var pending = request.pending;\n        for(var i = 0; i < pending.length; i++) {\n          pending[i]();\n        }\n        request.pending = null;\n      };\n\n      // if we have already resolved, pending is null, async call the callback\n      request.wait = function(fn) {\n        if (request.pending) {\n          request.pending.push(fn);\n        } else {\n          endOfMicrotask(fn);\n        }\n      };\n\n      return request;\n    }\n  };\n\n  scope.Loader = Loader;\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\nvar urlResolver = scope.urlResolver;\nvar Loader = scope.Loader;\n\nfunction StyleResolver() {\n  this.loader = new Loader(this.regex);\n}\nStyleResolver.prototype = {\n  regex: /@import\\s+(?:url)?[\"'\\(]*([^'\"\\)]*)['\"\\)]*;/g,\n  // Recursively replace @imports with the text at that url\n  resolve: function(text, url, callback) {\n    var done = function(map) {\n      callback(this.flatten(text, url, map));\n    }.bind(this);\n    this.loader.process(text, url, done);\n  },\n  // resolve the textContent of a style node\n  resolveNode: function(style, url, callback) {\n    var text = style.textContent;\n    var done = function(text) {\n      style.textContent = text;\n      callback(style);\n    };\n    this.resolve(text, url, done);\n  },\n  // flatten all the @imports to text\n  flatten: function(text, base, map) {\n    var matches = this.loader.extractUrls(text, base);\n    var match, url, intermediate;\n    for (var i = 0; i < matches.length; i++) {\n      match = matches[i];\n      url = match.url;\n      // resolve any css text to be relative to the importer, keep absolute url\n      intermediate = urlResolver.resolveCssText(map[url], url, true);\n      // flatten intermediate @imports\n      intermediate = this.flatten(intermediate, base, map);\n      text = text.replace(match.matched, intermediate);\n    }\n    return text;\n  },\n  loadStyles: function(styles, base, callback) {\n    var loaded=0, l = styles.length;\n    // called in the context of the style\n    function loadedStyle(style) {\n      loaded++;\n      if (loaded === l && callback) {\n        callback();\n      }\n    }\n    for (var i=0, s; (i<l) && (s=styles[i]); i++) {\n      this.resolveNode(s, base, loadedStyle);\n    }\n  }\n};\n\nvar styleResolver = new StyleResolver();\n\n// exports\nscope.styleResolver = styleResolver;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // copy own properties from 'api' to 'prototype, with name hinting for 'super'\n  function extend(prototype, api) {\n    if (prototype && api) {\n      // use only own properties of 'api'\n      Object.getOwnPropertyNames(api).forEach(function(n) {\n        // acquire property descriptor\n        var pd = Object.getOwnPropertyDescriptor(api, n);\n        if (pd) {\n          // clone property via descriptor\n          Object.defineProperty(prototype, n, pd);\n          // cache name-of-method for 'super' engine\n          if (typeof pd.value == 'function') {\n            // hint the 'super' engine\n            pd.value.nom = n;\n          }\n        }\n      });\n    }\n    return prototype;\n  }\n\n\n  // mixin\n\n  // copy all properties from inProps (et al) to inObj\n  function mixin(inObj/*, inProps, inMoreProps, ...*/) {\n    var obj = inObj || {};\n    for (var i = 1; i < arguments.length; i++) {\n      var p = arguments[i];\n      try {\n        for (var n in p) {\n          copyProperty(n, p, obj);\n        }\n      } catch(x) {\n      }\n    }\n    return obj;\n  }\n\n  // copy property inName from inSource object to inTarget object\n  function copyProperty(inName, inSource, inTarget) {\n    var pd = getPropertyDescriptor(inSource, inName);\n    Object.defineProperty(inTarget, inName, pd);\n  }\n\n  // get property descriptor for inName on inObject, even if\n  // inName exists on some link in inObject's prototype chain\n  function getPropertyDescriptor(inObject, inName) {\n    if (inObject) {\n      var pd = Object.getOwnPropertyDescriptor(inObject, inName);\n      return pd || getPropertyDescriptor(Object.getPrototypeOf(inObject), inName);\n    }\n  }\n\n  // exports\n\n  scope.extend = extend;\n  scope.mixin = mixin;\n\n  // for bc\n  Platform.mixin = mixin;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n  \n  // usage\n  \n  // invoke cb.call(this) in 100ms, unless the job is re-registered,\n  // which resets the timer\n  // \n  // this.myJob = this.job(this.myJob, cb, 100)\n  //\n  // returns a job handle which can be used to re-register a job\n\n  var Job = function(inContext) {\n    this.context = inContext;\n    this.boundComplete = this.complete.bind(this)\n  };\n  Job.prototype = {\n    go: function(callback, wait) {\n      this.callback = callback;\n      var h;\n      if (!wait) {\n        h = requestAnimationFrame(this.boundComplete);\n        this.handle = function() {\n          cancelAnimationFrame(h);\n        }\n      } else {\n        h = setTimeout(this.boundComplete, wait);\n        this.handle = function() {\n          clearTimeout(h);\n        }\n      }\n    },\n    stop: function() {\n      if (this.handle) {\n        this.handle();\n        this.handle = null;\n      }\n    },\n    complete: function() {\n      if (this.handle) {\n        this.stop();\n        this.callback.call(this.context);\n      }\n    }\n  };\n  \n  function job(job, callback, wait) {\n    if (job) {\n      job.stop();\n    } else {\n      job = new Job(this);\n    }\n    job.go(callback, wait);\n    return job;\n  }\n  \n  // exports \n\n  scope.job = job;\n  \n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  var registry = {};\n\n  HTMLElement.register = function(tag, prototype) {\n    registry[tag] = prototype;\n  }\n\n  // get prototype mapped to node <tag>\n  HTMLElement.getPrototypeForTag = function(tag) {\n    var prototype = !tag ? HTMLElement.prototype : registry[tag];\n    // TODO(sjmiles): creating <tag> is likely to have wasteful side-effects\n    return prototype || Object.getPrototypeOf(document.createElement(tag));\n  };\n\n  // we have to flag propagation stoppage for the event dispatcher\n  var originalStopPropagation = Event.prototype.stopPropagation;\n  Event.prototype.stopPropagation = function() {\n    this.cancelBubble = true;\n    originalStopPropagation.apply(this, arguments);\n  };\n  \n  \n  // polyfill DOMTokenList\n  // * add/remove: allow these methods to take multiple classNames\n  // * toggle: add a 2nd argument which forces the given state rather\n  //  than toggling.\n\n  var add = DOMTokenList.prototype.add;\n  var remove = DOMTokenList.prototype.remove;\n  DOMTokenList.prototype.add = function() {\n    for (var i = 0; i < arguments.length; i++) {\n      add.call(this, arguments[i]);\n    }\n  };\n  DOMTokenList.prototype.remove = function() {\n    for (var i = 0; i < arguments.length; i++) {\n      remove.call(this, arguments[i]);\n    }\n  };\n  DOMTokenList.prototype.toggle = function(name, bool) {\n    if (arguments.length == 1) {\n      bool = !this.contains(name);\n    }\n    bool ? this.add(name) : this.remove(name);\n  };\n  DOMTokenList.prototype.switch = function(oldName, newName) {\n    oldName && this.remove(oldName);\n    newName && this.add(newName);\n  };\n\n  // add array() to NodeList, NamedNodeMap, HTMLCollection\n\n  var ArraySlice = function() {\n    return Array.prototype.slice.call(this);\n  };\n\n  var namedNodeMap = (window.NamedNodeMap || window.MozNamedAttrMap || {});\n\n  NodeList.prototype.array = ArraySlice;\n  namedNodeMap.prototype.array = ArraySlice;\n  HTMLCollection.prototype.array = ArraySlice;\n\n  // utility\n\n  function createDOM(inTagOrNode, inHTML, inAttrs) {\n    var dom = typeof inTagOrNode == 'string' ?\n        document.createElement(inTagOrNode) : inTagOrNode.cloneNode(true);\n    dom.innerHTML = inHTML;\n    if (inAttrs) {\n      for (var n in inAttrs) {\n        dom.setAttribute(n, inAttrs[n]);\n      }\n    }\n    return dom;\n  }\n\n  // exports\n\n  scope.createDOM = createDOM;\n\n})(Polymer);\n",
    "/*\r\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\n\r\n (function(scope) {\r\n    // super\r\n\r\n    // `arrayOfArgs` is an optional array of args like one might pass\r\n    // to `Function.apply`\r\n\r\n    // TODO(sjmiles):\r\n    //    $super must be installed on an instance or prototype chain\r\n    //    as `super`, and invoked via `this`, e.g.\r\n    //      `this.super();`\r\n\r\n    //    will not work if function objects are not unique, for example,\r\n    //    when using mixins.\r\n    //    The memoization strategy assumes each function exists on only one \r\n    //    prototype chain i.e. we use the function object for memoizing)\r\n    //    perhaps we can bookkeep on the prototype itself instead\r\n    function $super(arrayOfArgs) {\r\n      // since we are thunking a method call, performance is important here: \r\n      // memoize all lookups, once memoized the fast path calls no other \r\n      // functions\r\n      //\r\n      // find the caller (cannot be `strict` because of 'caller')\r\n      var caller = $super.caller;\r\n      // memoized 'name of method' \r\n      var nom = caller.nom;\r\n      // memoized next implementation prototype\r\n      var _super = caller._super;\r\n      if (!_super) {\r\n        if (!nom) {\r\n          nom = caller.nom = nameInThis.call(this, caller);\r\n        }\r\n        if (!nom) {\r\n          console.warn('called super() on a method not installed declaratively (has no .nom property)');\r\n        }\r\n        // super prototype is either cached or we have to find it\r\n        // by searching __proto__ (at the 'top')\r\n        // invariant: because we cache _super on fn below, we never reach \r\n        // here from inside a series of calls to super(), so it's ok to \r\n        // start searching from the prototype of 'this' (at the 'top')\r\n        // we must never memoize a null super for this reason\r\n        _super = memoizeSuper(caller, nom, getPrototypeOf(this));\r\n      }\r\n      // our super function\r\n      var fn = _super[nom];\r\n      if (fn) {\r\n        // memoize information so 'fn' can call 'super'\r\n        if (!fn._super) {\r\n          // must not memoize null, or we lose our invariant above\r\n          memoizeSuper(fn, nom, _super);\r\n        }\r\n        // invoke the inherited method\r\n        // if 'fn' is not function valued, this will throw\r\n        return fn.apply(this, arrayOfArgs || []);\r\n      }\r\n    }\r\n\r\n    function nameInThis(value) {\r\n      var p = this.__proto__;\r\n      while (p && p !== HTMLElement.prototype) {\r\n        // TODO(sjmiles): getOwnPropertyNames is absurdly expensive\r\n        var n$ = Object.getOwnPropertyNames(p);\r\n        for (var i=0, l=n$.length, n; i<l && (n=n$[i]); i++) {\r\n          var d = Object.getOwnPropertyDescriptor(p, n);\r\n          if (typeof d.value === 'function' && d.value === value) {\r\n            return n;\r\n          }\r\n        }\r\n        p = p.__proto__;\r\n      }\r\n    }\r\n\r\n    function memoizeSuper(method, name, proto) {\r\n      // find and cache next prototype containing `name`\r\n      // we need the prototype so we can do another lookup\r\n      // from here\r\n      var s = nextSuper(proto, name, method);\r\n      if (s[name]) {\r\n        // `s` is a prototype, the actual method is `s[name]`\r\n        // tag super method with it's name for quicker lookups\r\n        s[name].nom = name;\r\n      }\r\n      return method._super = s;\r\n    }\r\n\r\n    function nextSuper(proto, name, caller) {\r\n      // look for an inherited prototype that implements name\r\n      while (proto) {\r\n        if ((proto[name] !== caller) && proto[name]) {\r\n          return proto;\r\n        }\r\n        proto = getPrototypeOf(proto);\r\n      }\r\n      // must not return null, or we lose our invariant above\r\n      // in this case, a super() call was invoked where no superclass\r\n      // method exists\r\n      // TODO(sjmiles): thow an exception?\r\n      return Object;\r\n    }\r\n\r\n    // NOTE: In some platforms (IE10) the prototype chain is faked via \r\n    // __proto__. Therefore, always get prototype via __proto__ instead of\r\n    // the more standard Object.getPrototypeOf.\r\n    function getPrototypeOf(prototype) {\r\n      return prototype.__proto__;\r\n    }\r\n\r\n    // utility function to precompute name tags for functions\r\n    // in a (unchained) prototype\r\n    function hintSuper(prototype) {\r\n      // tag functions with their prototype name to optimize\r\n      // super call invocations\r\n      for (var n in prototype) {\r\n        var pd = Object.getOwnPropertyDescriptor(prototype, n);\r\n        if (pd && typeof pd.value === 'function') {\r\n          pd.value.nom = n;\r\n        }\r\n      }\r\n    }\r\n\r\n    // exports\r\n\r\n    scope.super = $super;\r\n\r\n})(Polymer);\r\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  function noopHandler(value) {\n    return value;\n  }\n\n  var typeHandlers = {\n    string: noopHandler,\n    'undefined': noopHandler,\n    date: function(value) {\n      return new Date(Date.parse(value) || Date.now());\n    },\n    boolean: function(value) {\n      if (value === '') {\n        return true;\n      }\n      return value === 'false' ? false : !!value;\n    },\n    number: function(value) {\n      var n = parseFloat(value);\n      // hex values like \"0xFFFF\" parseFloat as 0\n      if (n === 0) {\n        n = parseInt(value);\n      }\n      return isNaN(n) ? value : n;\n      // this code disabled because encoded values (like \"0xFFFF\")\n      // do not round trip to their original format\n      //return (String(floatVal) === value) ? floatVal : value;\n    },\n    object: function(value, currentValue) {\n      if (currentValue === null) {\n        return value;\n      }\n      try {\n        // If the string is an object, we can parse is with the JSON library.\n        // include convenience replace for single-quotes. If the author omits\n        // quotes altogether, parse will fail.\n        return JSON.parse(value.replace(/'/g, '\"'));\n      } catch(e) {\n        // The object isn't valid JSON, return the raw value\n        return value;\n      }\n    },\n    // avoid deserialization of functions\n    'function': function(value, currentValue) {\n      return currentValue;\n    }\n  };\n\n  function deserializeValue(value, currentValue) {\n    // attempt to infer type from default value\n    var inferredType = typeof currentValue;\n    // invent 'date' type value for Date\n    if (currentValue instanceof Date) {\n      inferredType = 'date';\n    }\n    // delegate deserialization via type string\n    return typeHandlers[inferredType](value, currentValue);\n  }\n\n  // exports\n\n  scope.deserializeValue = deserializeValue;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(function(scope) {\n\n  // imports\n\n  var extend = scope.extend;\n\n  // module\n\n  var api = {};\n\n  api.declaration = {};\n  api.instance = {};\n\n  api.publish = function(apis, prototype) {\n    for (var n in apis) {\n      extend(prototype, apis[n]);\n    }\n  };\n\n  // exports\n\n  scope.api = api;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  var utils = {\n    /**\n      * Invokes a function asynchronously. The context of the callback\n      * function is bound to 'this' automatically.\n      * @method async\n      * @param {Function|String} method\n      * @param {any|Array} args\n      * @param {number} timeout\n      */\n    async: function(method, args, timeout) {\n      // when polyfilling Object.observe, ensure changes \n      // propagate before executing the async method\n      Platform.flush();\n      // second argument to `apply` must be an array\n      args = (args && args.length) ? args : [args];\n      // function to invoke\n      var fn = function() {\n        (this[method] || method).apply(this, args);\n      }.bind(this);\n      // execute `fn` sooner or later\n      var handle = timeout ? setTimeout(fn, timeout) :\n          requestAnimationFrame(fn);\n      // NOTE: switch on inverting handle to determine which time is used.\n      return timeout ? handle : ~handle;\n    },\n    cancelAsync: function(handle) {\n      if (handle < 0) {\n        cancelAnimationFrame(~handle);\n      } else {\n        clearTimeout(handle);\n      }\n    },\n    /**\n      * Fire an event.\n      * @method fire\n      * @returns {Object} event\n      * @param {string} type An event name.\n      * @param {any} detail\n      * @param {Node} onNode Target node.\n      * @param {Boolean} bubbles Set false to prevent bubbling, defaults to true\n      * @param {Boolean} cancelable Set false to prevent cancellation, defaults to true\n      */\n    fire: function(type, detail, onNode, bubbles, cancelable) {\n      var node = onNode || this;\n      var detail = detail === null || detail === undefined ? {} : detail;\n      var event = new CustomEvent(type, {\n        bubbles: bubbles !== undefined ? bubbles : true,\n        cancelable: cancelable !== undefined ? cancelable : true,\n        detail: detail\n      });\n      node.dispatchEvent(event);\n      return event;\n    },\n    /**\n      * Fire an event asynchronously.\n      * @method asyncFire\n      * @param {string} type An event name.\n      * @param detail\n      * @param {Node} toNode Target node.\n      */\n    asyncFire: function(/*inType, inDetail*/) {\n      this.async(\"fire\", arguments);\n    },\n    /**\n      * Remove class from old, add class to anew, if they exist.\n      * @param classFollows\n      * @param anew A node.\n      * @param old A node\n      * @param className\n      */\n    classFollows: function(anew, old, className) {\n      if (old) {\n        old.classList.remove(className);\n      }\n      if (anew) {\n        anew.classList.add(className);\n      }\n    },\n    /**\n      * Inject HTML which contains markup bound to this element into\n      * a target element (replacing target element content).\n      * @param String html to inject\n      * @param Element target element\n      */\n    injectBoundHTML: function(html, element) {\n      var template = document.createElement('template');\n      template.innerHTML = html;\n      var fragment = this.instanceTemplate(template);\n      if (element) {\n        element.textContent = '';\n        element.appendChild(fragment);\n      }\n      return fragment;\n    }\n  };\n\n  // no-operation function for handy stubs\n  var nop = function() {};\n\n  // null-object for handy stubs\n  var nob = {};\n\n  // deprecated\n\n  utils.asyncMethod = utils.async;\n\n  // exports\n\n  scope.api.instance.utils = utils;\n  scope.nop = nop;\n  scope.nob = nob;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n  var EVENT_PREFIX = 'on-';\n\n  // instance events api\n  var events = {\n    // read-only\n    EVENT_PREFIX: EVENT_PREFIX,\n    // event listeners on host\n    addHostListeners: function() {\n      var events = this.eventDelegates;\n      log.events && (Object.keys(events).length > 0) && console.log('[%s] addHostListeners:', this.localName, events);\n      // NOTE: host events look like bindings but really are not;\n      // (1) we don't want the attribute to be set and (2) we want to support\n      // multiple event listeners ('host' and 'instance') and Node.bind\n      // by default supports 1 thing being bound.\n      for (var type in events) {\n        var methodName = events[type];\n        PolymerGestures.addEventListener(this, type, this.element.getEventHandler(this, this, methodName));\n      }\n    },\n    // call 'method' or function method on 'obj' with 'args', if the method exists\n    dispatchMethod: function(obj, method, args) {\n      if (obj) {\n        log.events && console.group('[%s] dispatch [%s]', obj.localName, method);\n        var fn = typeof method === 'function' ? method : obj[method];\n        if (fn) {\n          fn[args ? 'apply' : 'call'](obj, args);\n        }\n        log.events && console.groupEnd();\n        Platform.flush();\n      }\n    }\n  };\n\n  // exports\n\n  scope.api.instance.events = events;\n\n  // alias PolymerGestures event listener logic\n  scope.addEventListener = PolymerGestures.addEventListener;\n  scope.removeEventListener = PolymerGestures.removeEventListener;\n\n})(Polymer);\n",
    "/*\r\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\r\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\n * Code distributed by Google as part of the polymer project is also\r\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n */\r\n\r\n(function(scope) {\r\n\r\n  // instance api for attributes\r\n\r\n  var attributes = {\r\n    copyInstanceAttributes: function () {\r\n      var a$ = this._instanceAttributes;\r\n      for (var k in a$) {\r\n        if (!this.hasAttribute(k)) {\r\n          this.setAttribute(k, a$[k]);\r\n        }\r\n      }\r\n    },\r\n    // for each attribute on this, deserialize value to property as needed\r\n    takeAttributes: function() {\r\n      // if we have no publish lookup table, we have no attributes to take\r\n      // TODO(sjmiles): ad hoc\r\n      if (this._publishLC) {\r\n        for (var i=0, a$=this.attributes, l=a$.length, a; (a=a$[i]) && i<l; i++) {\r\n          this.attributeToProperty(a.name, a.value);\r\n        }\r\n      }\r\n    },\r\n    // if attribute 'name' is mapped to a property, deserialize\r\n    // 'value' into that property\r\n    attributeToProperty: function(name, value) {\r\n      // try to match this attribute to a property (attributes are\r\n      // all lower-case, so this is case-insensitive search)\r\n      var name = this.propertyForAttribute(name);\r\n      if (name) {\r\n        // filter out 'mustached' values, these are to be\r\n        // replaced with bound-data and are not yet values\r\n        // themselves\r\n        if (value && value.search(scope.bindPattern) >= 0) {\r\n          return;\r\n        }\r\n        // get original value\r\n        var currentValue = this[name];\r\n        // deserialize Boolean or Number values from attribute\r\n        var value = this.deserializeValue(value, currentValue);\r\n        // only act if the value has changed\r\n        if (value !== currentValue) {\r\n          // install new value (has side-effects)\r\n          this[name] = value;\r\n        }\r\n      }\r\n    },\r\n    // return the published property matching name, or undefined\r\n    propertyForAttribute: function(name) {\r\n      var match = this._publishLC && this._publishLC[name];\r\n      //console.log('propertyForAttribute:', name, 'matches', match);\r\n      return match;\r\n    },\r\n    // convert representation of 'stringValue' based on type of 'currentValue'\r\n    deserializeValue: function(stringValue, currentValue) {\r\n      return scope.deserializeValue(stringValue, currentValue);\r\n    },\r\n    serializeValue: function(value, inferredType) {\r\n      if (inferredType === 'boolean') {\r\n        return value ? '' : undefined;\r\n      } else if (inferredType !== 'object' && inferredType !== 'function'\r\n          && value !== undefined) {\r\n        return value;\r\n      }\r\n    },\r\n    reflectPropertyToAttribute: function(name) {\r\n      var inferredType = typeof this[name];\r\n      // try to intelligently serialize property value\r\n      var serializedValue = this.serializeValue(this[name], inferredType);\r\n      // boolean properties must reflect as boolean attributes\r\n      if (serializedValue !== undefined) {\r\n        this.setAttribute(name, serializedValue);\r\n        // TODO(sorvell): we should remove attr for all properties\r\n        // that have undefined serialization; however, we will need to\r\n        // refine the attr reflection system to achieve this; pica, for example,\r\n        // relies on having inferredType object properties not removed as\r\n        // attrs.\r\n      } else if (inferredType === 'boolean') {\r\n        this.removeAttribute(name);\r\n      }\r\n    }\r\n  };\r\n\r\n  // exports\r\n\r\n  scope.api.instance.attributes = attributes;\r\n\r\n})(Polymer);\r\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n\n  // magic words\n\n  var OBSERVE_SUFFIX = 'Changed';\n\n  // element api\n\n  var empty = [];\n\n  var updateRecord = {\n    object: undefined,\n    type: 'update',\n    name: undefined,\n    oldValue: undefined\n  };\n\n  var numberIsNaN = Number.isNaN || function(value) {\n    return typeof value === 'number' && isNaN(value);\n  }\n\n  function areSameValue(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    if (numberIsNaN(left) && numberIsNaN(right))\n      return true;\n\n    return left !== left && right !== right;\n  }\n\n  // capture A's value if B's value is null or undefined,\n  // otherwise use B's value\n  function resolveBindingValue(oldValue, value) {\n    if (value === undefined && oldValue === null) {\n      return value;\n    }\n    return (value === null || value === undefined) ? oldValue : value;\n  }\n\n  var properties = {\n    createPropertyObserver: function() {\n      var n$ = this._observeNames;\n      if (n$ && n$.length) {\n        var o = this._propertyObserver = new CompoundObserver(true);\n        this.registerObserver(o);\n        // TODO(sorvell): may not be kosher to access the value here (this[n]);\n        // previously we looked at the descriptor on the prototype\n        // this doesn't work for inheritance and not for accessors without\n        // a value property\n        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n          o.addPath(this, n);\n          this.observeArrayValue(n, this[n], null);\n        }\n      }\n    },\n    openPropertyObserver: function() {\n      if (this._propertyObserver) {\n        this._propertyObserver.open(this.notifyPropertyChanges, this);\n      }\n    },\n    notifyPropertyChanges: function(newValues, oldValues, paths) {\n      var name, method, called = {};\n      for (var i in oldValues) {\n        // note: paths is of form [object, path, object, path]\n        name = paths[2 * i + 1];\n        method = this.observe[name];\n        if (method) {\n          var ov = oldValues[i], nv = newValues[i];\n          // observes the value if it is an array\n          this.observeArrayValue(name, nv, ov);\n          if (!called[method]) {\n            // only invoke change method if one of ov or nv is not (undefined | null)\n            if ((ov !== undefined && ov !== null) || (nv !== undefined && nv !== null)) {\n              called[method] = true;\n              // TODO(sorvell): call method with the set of values it's expecting;\n              // e.g. 'foo bar': 'invalidate' expects the new and old values for\n              // foo and bar. Currently we give only one of these and then\n              // deliver all the arguments.\n              this.invokeMethod(method, [ov, nv, arguments]);\n            }\n          }\n        }\n      }\n    },\n    deliverChanges: function() {\n      if (this._propertyObserver) {\n        this._propertyObserver.deliver();\n      }\n    },\n    propertyChanged_: function(name, value, oldValue) {\n      if (this.reflect[name]) {\n        this.reflectPropertyToAttribute(name);\n      }\n    },\n    observeArrayValue: function(name, value, old) {\n      // we only care if there are registered side-effects\n      var callbackName = this.observe[name];\n      if (callbackName) {\n        // if we are observing the previous value, stop\n        if (Array.isArray(old)) {\n          log.observe && console.log('[%s] observeArrayValue: unregister observer [%s]', this.localName, name);\n          this.closeNamedObserver(name + '__array');\n        }\n        // if the new value is an array, being observing it\n        if (Array.isArray(value)) {\n          log.observe && console.log('[%s] observeArrayValue: register observer [%s]', this.localName, name, value);\n          var observer = new ArrayObserver(value);\n          observer.open(function(splices) {\n            this.invokeMethod(callbackName, [splices]);\n          }, this);\n          this.registerNamedObserver(name + '__array', observer);\n        }\n      }\n    },\n    emitPropertyChangeRecord: function(name, value, oldValue) {\n      var object = this;\n      if (areSameValue(value, oldValue))\n        return;\n\n      this.propertyChanged_(name, value, oldValue);\n\n      if (!Observer.hasObjectObserve)\n        return;\n\n      var notifier = this.notifier_;\n      if (!notifier)\n        notifier = this.notifier_ = Object.getNotifier(this);\n\n      updateRecord.object = this;\n      updateRecord.name = name;\n      updateRecord.oldValue = oldValue;\n\n      notifier.notify(updateRecord);\n    },\n    bindToAccessor: function(name, observable, resolveFn) {\n      var privateName = name + '_';\n      var privateObservable  = name + 'Observable_';\n\n      this[privateObservable] = observable;\n      var oldValue = this[privateName];\n\n      var self = this;\n      var value = observable.open(function(value, oldValue) {\n        self[privateName] = value;\n        self.emitPropertyChangeRecord(name, value, oldValue);\n      });\n\n      if (resolveFn && !areSameValue(oldValue, value)) {\n        var resolvedValue = resolveFn(oldValue, value);\n        if (!areSameValue(value, resolvedValue)) {\n          value = resolvedValue;\n          if (observable.setValue)\n            observable.setValue(value);\n        }\n      }\n\n      this[privateName] = value;\n      this.emitPropertyChangeRecord(name, value, oldValue);\n\n      var observer = {\n        close: function() {\n          observable.close();\n          self[privateObservable] = undefined;\n        }\n      };\n      this.registerObserver(observer);\n      return observer;\n    },\n    createComputedProperties: function() {\n      if (!this._computedNames) {\n        return;\n      }\n\n      for (var i = 0; i < this._computedNames.length; i++) {\n        var name = this._computedNames[i];\n        var expressionText = this.computed[name];\n        try {\n          var expression = PolymerExpressions.getExpression(expressionText);\n          var observable = expression.getBinding(this, this.element.syntax);\n          this.bindToAccessor(name, observable);\n        } catch (ex) {\n          console.error('Failed to create computed property', ex);\n        }\n      }\n    },\n    bindProperty: function(property, observable, oneTime) {\n      if (oneTime) {\n        this[property] = observable;\n        return;\n      }\n      return this.bindToAccessor(property, observable, resolveBindingValue);\n    },\n    invokeMethod: function(method, args) {\n      var fn = this[method] || method;\n      if (typeof fn === 'function') {\n        fn.apply(this, args);\n      }\n    },\n    registerObserver: function(observer) {\n      if (!this._observers) {\n        this._observers = [observer];\n        return;\n      }\n\n      this._observers.push(observer);\n    },\n    // observer array items are arrays of observers.\n    closeObservers: function() {\n      if (!this._observers) {\n        return;\n      }\n\n      var observers = this._observers;\n      for (var i = 0; i < observers.length; i++) {\n        var observer = observers[i];\n        if (observer && typeof observer.close == 'function') {\n          observer.close();\n        }\n      }\n\n      this._observers = [];\n    },\n    // bookkeeping observers for memory management\n    registerNamedObserver: function(name, observer) {\n      var o$ = this._namedObservers || (this._namedObservers = {});\n      o$[name] = observer;\n    },\n    closeNamedObserver: function(name) {\n      var o$ = this._namedObservers;\n      if (o$ && o$[name]) {\n        o$[name].close();\n        o$[name] = null;\n        return true;\n      }\n    },\n    closeNamedObservers: function() {\n      if (this._namedObservers) {\n        for (var i in this._namedObservers) {\n          this.closeNamedObserver(i);\n        }\n        this._namedObservers = {};\n      }\n    }\n  };\n\n  // logging\n  var LOG_OBSERVE = '[%s] watching [%s]';\n  var LOG_OBSERVED = '[%s#%s] watch: [%s] now [%s] was [%s]';\n  var LOG_CHANGED = '[%s#%s] propertyChanged: [%s] now [%s] was [%s]';\n\n  // exports\n\n  scope.api.instance.properties = properties;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || 0;\n\n  // element api supporting mdv\n  var mdv = {\n    instanceTemplate: function(template) {\n      // ensure template is decorated (lets' things like <tr template ...> work)\n      HTMLTemplateElement.decorate(template);\n      // ensure a default bindingDelegate\n      var syntax = this.syntax || (!template.bindingDelegate &&\n          this.element.syntax);\n      var dom = template.createInstance(this, syntax);\n      var observers = dom.bindings_;\n      for (var i = 0; i < observers.length; i++) {\n        this.registerObserver(observers[i]);\n      }\n      return dom;\n    },\n    bind: function(name, observable, oneTime) {\n      var property = this.propertyForAttribute(name);\n      if (!property) {\n        // TODO(sjmiles): this mixin method must use the special form\n        // of `super` installed by `mixinMethod` in declaration/prototype.js\n        return this.mixinSuper(arguments);\n      } else {\n        // use n-way Polymer binding\n        var observer = this.bindProperty(property, observable, oneTime);\n        // NOTE: reflecting binding information is typically required only for\n        // tooling. It has a performance cost so it's opt-in in Node.bind.\n        if (Platform.enableBindingsReflection && observer) {\n          observer.path = observable.path_;\n          this._recordBinding(property, observer);\n        }\n        if (this.reflect[property]) {\n          this.reflectPropertyToAttribute(property);\n        }\n        return observer;\n      }\n    },\n    bindFinished: function() {\n      this.makeElementReady();\n    },\n    _recordBinding: function(name, observer) {\n      this.bindings_ = this.bindings_ || {};\n      this.bindings_[name] = observer;\n    },\n    // TODO(sorvell): unbind/unbindAll has been removed, as public api, from\n    // TemplateBinding. We still need to close/dispose of observers but perhaps\n    // we should choose a more explicit name.\n    asyncUnbindAll: function() {\n      if (!this._unbound) {\n        log.unbind && console.log('[%s] asyncUnbindAll', this.localName);\n        this._unbindAllJob = this.job(this._unbindAllJob, this.unbindAll, 0);\n      }\n    },\n    unbindAll: function() {\n      if (!this._unbound) {\n        this.closeObservers();\n        this.closeNamedObservers();\n        this._unbound = true;\n      }\n    },\n    cancelUnbindAll: function() {\n      if (this._unbound) {\n        log.unbind && console.warn('[%s] already unbound, cannot cancel unbindAll', this.localName);\n        return;\n      }\n      log.unbind && console.log('[%s] cancelUnbindAll', this.localName);\n      if (this._unbindAllJob) {\n        this._unbindAllJob = this._unbindAllJob.stop();\n      }\n    }\n  };\n\n  function unbindNodeTree(node) {\n    forNodeTree(node, _nodeUnbindAll);\n  }\n\n  function _nodeUnbindAll(node) {\n    node.unbindAll();\n  }\n\n  function forNodeTree(node, callback) {\n    if (node) {\n      callback(node);\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        forNodeTree(child, callback);\n      }\n    }\n  }\n\n  var mustachePattern = /\\{\\{([^{}]*)}}/;\n\n  // exports\n\n  scope.bindPattern = mustachePattern;\n  scope.api.instance.mdv = mdv;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  var base = {\n    PolymerBase: true,\n    job: function(job, callback, wait) {\n      if (typeof job === 'string') {\n        var n = '___' + job;\n        this[n] = Polymer.job.call(this, this[n], callback, wait);\n      } else {\n        return Polymer.job.call(this, job, callback, wait);\n      }\n    },\n    super: Polymer.super,\n    // user entry point for element has had its createdCallback called\n    created: function() {\n    },\n    // user entry point for element has shadowRoot and is ready for\n    // api interaction\n    ready: function() {\n    },\n    createdCallback: function() {\n      if (this.templateInstance && this.templateInstance.model) {\n        console.warn('Attributes on ' + this.localName + ' were data bound ' +\n            'prior to Polymer upgrading the element. This may result in ' +\n            'incorrect binding types.');\n      }\n      this.created();\n      this.prepareElement();\n      if (!this.ownerDocument.isStagingDocument) {\n        this.makeElementReady();\n      }\n    },\n    // system entry point, do not override\n    prepareElement: function() {\n      if (this._elementPrepared) {\n        console.warn('Element already prepared', this.localName);\n        return;\n      }\n      this._elementPrepared = true;\n      // storage for shadowRoots info\n      this.shadowRoots = {};\n      // install property observers\n      this.createPropertyObserver();\n      this.openPropertyObserver();\n      // install boilerplate attributes\n      this.copyInstanceAttributes();\n      // process input attributes\n      this.takeAttributes();\n      // add event listeners\n      this.addHostListeners();\n    },\n    makeElementReady: function() {\n      if (this._readied) {\n        return;\n      }\n      this._readied = true;\n      this.createComputedProperties();\n      // TODO(sorvell): We could create an entry point here\n      // for the user to compute property values.\n      // process declarative resources\n      this.parseDeclarations(this.__proto__);\n      // TODO(sorvell): CE polyfill uses unresolved attribute to simulate\n      // :unresolved; remove this attribute to be compatible with native\n      // CE.\n      this.removeAttribute('unresolved');\n      // user entry point\n      this.ready();\n    },\n    attachedCallback: function() {\n      this.cancelUnbindAll();\n      // invoke user action\n      if (this.attached) {\n        this.attached();\n      }\n      // TODO(sorvell): bc\n      if (this.enteredView) {\n        this.enteredView();\n      }\n      // NOTE: domReady can be used to access elements in dom (descendants,\n      // ancestors, siblings) such that the developer is enured to upgrade\n      // ordering. If the element definitions have loaded, domReady\n      // can be used to access upgraded elements.\n      if (!this.hasBeenAttached) {\n        this.hasBeenAttached = true;\n        if (this.domReady) {\n          this.async('domReady');\n        }\n      }\n    },\n    detachedCallback: function() {\n      if (!this.preventDispose) {\n        this.asyncUnbindAll();\n      }\n      // invoke user action\n      if (this.detached) {\n        this.detached();\n      }\n      // TODO(sorvell): bc\n      if (this.leftView) {\n        this.leftView();\n      }\n    },\n    // TODO(sorvell): bc\n    enteredViewCallback: function() {\n      this.attachedCallback();\n    },\n    // TODO(sorvell): bc\n    leftViewCallback: function() {\n      this.detachedCallback();\n    },\n    // TODO(sorvell): bc\n    enteredDocumentCallback: function() {\n      this.attachedCallback();\n    },\n    // TODO(sorvell): bc\n    leftDocumentCallback: function() {\n      this.detachedCallback();\n    },\n    // recursive ancestral <element> initialization, oldest first\n    parseDeclarations: function(p) {\n      if (p && p.element) {\n        this.parseDeclarations(p.__proto__);\n        p.parseDeclaration.call(this, p.element);\n      }\n    },\n    // parse input <element> as needed, override for custom behavior\n    parseDeclaration: function(elementElement) {\n      var template = this.fetchTemplate(elementElement);\n      if (template) {\n        var root = this.shadowFromTemplate(template);\n        this.shadowRoots[elementElement.name] = root;\n      }\n    },\n    // return a shadow-root template (if desired), override for custom behavior\n    fetchTemplate: function(elementElement) {\n      return elementElement.querySelector('template');\n    },\n    // utility function that creates a shadow root from a <template>\n    shadowFromTemplate: function(template) {\n      if (template) {\n        // make a shadow root\n        var root = this.createShadowRoot();\n        // stamp template\n        // which includes parsing and applying MDV bindings before being\n        // inserted (to avoid {{}} in attribute values)\n        // e.g. to prevent <img src=\"images/{{icon}}\"> from generating a 404.\n        var dom = this.instanceTemplate(template);\n        // append to shadow dom\n        root.appendChild(dom);\n        // perform post-construction initialization tasks on shadow root\n        this.shadowRootReady(root, template);\n        // return the created shadow root\n        return root;\n      }\n    },\n    // utility function that stamps a <template> into light-dom\n    lightFromTemplate: function(template, refNode) {\n      if (template) {\n        // TODO(sorvell): mark this element as an eventController so that\n        // event listeners on bound nodes inside it will be called on it.\n        // Note, the expectation here is that events on all descendants\n        // should be handled by this element.\n        this.eventController = this;\n        // stamp template\n        // which includes parsing and applying MDV bindings before being\n        // inserted (to avoid {{}} in attribute values)\n        // e.g. to prevent <img src=\"images/{{icon}}\"> from generating a 404.\n        var dom = this.instanceTemplate(template);\n        // append to shadow dom\n        if (refNode) {\n          this.insertBefore(dom, refNode);\n        } else {\n          this.appendChild(dom);\n        }\n        // perform post-construction initialization tasks on ahem, light root\n        this.shadowRootReady(this);\n        // return the created shadow root\n        return dom;\n      }\n    },\n    shadowRootReady: function(root) {\n      // locate nodes with id and store references to them in this.$ hash\n      this.marshalNodeReferences(root);\n    },\n    // locate nodes with id and store references to them in this.$ hash\n    marshalNodeReferences: function(root) {\n      // establish $ instance variable\n      var $ = this.$ = this.$ || {};\n      // populate $ from nodes with ID from the LOCAL tree\n      if (root) {\n        var n$ = root.querySelectorAll(\"[id]\");\n        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n          $[n.id] = n;\n        };\n      }\n    },\n    attributeChangedCallback: function(name, oldValue) {\n      // TODO(sjmiles): adhoc filter\n      if (name !== 'class' && name !== 'style') {\n        this.attributeToProperty(name, this.getAttribute(name));\n      }\n      if (this.attributeChanged) {\n        this.attributeChanged.apply(this, arguments);\n      }\n    },\n    onMutation: function(node, listener) {\n      var observer = new MutationObserver(function(mutations) {\n        listener.call(this, observer, mutations);\n        observer.disconnect();\n      }.bind(this));\n      observer.observe(node, {childList: true, subtree: true});\n    }\n  };\n\n  // true if object has own PolymerBase api\n  function isBase(object) {\n    return object.hasOwnProperty('PolymerBase')\n  }\n\n  // name a base constructor for dev tools\n\n  function PolymerBase() {};\n  PolymerBase.prototype = base;\n  base.constructor = PolymerBase;\n\n  // exports\n\n  scope.Base = PolymerBase;\n  scope.isBase = isBase;\n  scope.api.instance.base = base;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n  var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;\n\n  // magic words\n  \n  var STYLE_SCOPE_ATTRIBUTE = 'element';\n  var STYLE_CONTROLLER_SCOPE = 'controller';\n  \n  var styles = {\n    STYLE_SCOPE_ATTRIBUTE: STYLE_SCOPE_ATTRIBUTE,\n    /**\n     * Installs external stylesheets and <style> elements with the attribute \n     * polymer-scope='controller' into the scope of element. This is intended\n     * to be a called during custom element construction.\n    */\n    installControllerStyles: function() {\n      // apply controller styles, but only if they are not yet applied\n      var scope = this.findStyleScope();\n      if (scope && !this.scopeHasNamedStyle(scope, this.localName)) {\n        // allow inherited controller styles\n        var proto = getPrototypeOf(this), cssText = '';\n        while (proto && proto.element) {\n          cssText += proto.element.cssTextForScope(STYLE_CONTROLLER_SCOPE);\n          proto = getPrototypeOf(proto);\n        }\n        if (cssText) {\n          this.installScopeCssText(cssText, scope);\n        }\n      }\n    },\n    installScopeStyle: function(style, name, scope) {\n      var scope = scope || this.findStyleScope(), name = name || '';\n      if (scope && !this.scopeHasNamedStyle(scope, this.localName + name)) {\n        var cssText = '';\n        if (style instanceof Array) {\n          for (var i=0, l=style.length, s; (i<l) && (s=style[i]); i++) {\n            cssText += s.textContent + '\\n\\n';\n          }\n        } else {\n          cssText = style.textContent;\n        }\n        this.installScopeCssText(cssText, scope, name);\n      }\n    },\n    installScopeCssText: function(cssText, scope, name) {\n      scope = scope || this.findStyleScope();\n      name = name || '';\n      if (!scope) {\n        return;\n      }\n      if (hasShadowDOMPolyfill) {\n        cssText = shimCssText(cssText, scope.host);\n      }\n      var style = this.element.cssTextToScopeStyle(cssText,\n          STYLE_CONTROLLER_SCOPE);\n      Polymer.applyStyleToScope(style, scope);\n      // cache that this style has been applied\n      this.styleCacheForScope(scope)[this.localName + name] = true;\n    },\n    findStyleScope: function(node) {\n      // find the shadow root that contains this element\n      var n = node || this;\n      while (n.parentNode) {\n        n = n.parentNode;\n      }\n      return n;\n    },\n    scopeHasNamedStyle: function(scope, name) {\n      var cache = this.styleCacheForScope(scope);\n      return cache[name];\n    },\n    styleCacheForScope: function(scope) {\n      if (hasShadowDOMPolyfill) {\n        var scopeName = scope.host ? scope.host.localName : scope.localName;\n        return polyfillScopeStyleCache[scopeName] || (polyfillScopeStyleCache[scopeName] = {});\n      } else {\n        return scope._scopeStyles = (scope._scopeStyles || {});\n      }\n    }\n  };\n\n  var polyfillScopeStyleCache = {};\n  \n  // NOTE: use raw prototype traversal so that we ensure correct traversal\n  // on platforms where the protoype chain is simulated via __proto__ (IE10)\n  function getPrototypeOf(prototype) {\n    return prototype.__proto__;\n  }\n\n  function shimCssText(cssText, host) {\n    var name = '', is = false;\n    if (host) {\n      name = host.localName;\n      is = host.hasAttribute('is');\n    }\n    var selector = Platform.ShadowCSS.makeScopeSelector(name, is);\n    return Platform.ShadowCSS.shimCssText(cssText, selector);\n  }\n\n  // exports\n\n  scope.api.instance.styles = styles;\n  \n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // imports\n\n  var extend = scope.extend;\n  var api = scope.api;\n\n  // imperative implementation: Polymer()\n\n  // specify an 'own' prototype for tag `name`\n  function element(name, prototype) {\n    if (typeof name !== 'string') {\n      var script = prototype || document._currentScript;\n      prototype = name;\n      name = script && script.parentNode && script.parentNode.getAttribute ?\n          script.parentNode.getAttribute('name') : '';\n      if (!name) {\n        throw 'Element name could not be inferred.';\n      }\n    }\n    if (getRegisteredPrototype[name]) {\n      throw 'Already registered (Polymer) prototype for element ' + name;\n    }\n    // cache the prototype\n    registerPrototype(name, prototype);\n    // notify the registrar waiting for 'name', if any\n    notifyPrototype(name);\n  }\n\n  // async prototype source\n\n  function waitingForPrototype(name, client) {\n    waitPrototype[name] = client;\n  }\n\n  var waitPrototype = {};\n\n  function notifyPrototype(name) {\n    if (waitPrototype[name]) {\n      waitPrototype[name].registerWhenReady();\n      delete waitPrototype[name];\n    }\n  }\n\n  // utility and bookkeeping\n\n  // maps tag names to prototypes, as registered with\n  // Polymer. Prototypes associated with a tag name\n  // using document.registerElement are available from\n  // HTMLElement.getPrototypeForTag().\n  // If an element was fully registered by Polymer, then\n  // Polymer.getRegisteredPrototype(name) === \n  //   HTMLElement.getPrototypeForTag(name)\n\n  var prototypesByName = {};\n\n  function registerPrototype(name, prototype) {\n    return prototypesByName[name] = prototype || {};\n  }\n\n  function getRegisteredPrototype(name) {\n    return prototypesByName[name];\n  }\n\n  // exports\n\n  scope.getRegisteredPrototype = getRegisteredPrototype;\n  scope.waitingForPrototype = waitingForPrototype;\n\n  // namespace shenanigans so we can expose our scope on the registration \n  // function\n\n  // make window.Polymer reference `element()`\n\n  window.Polymer = element;\n\n  // TODO(sjmiles): find a way to do this that is less terrible\n  // copy window.Polymer properties onto `element()`\n\n  extend(Polymer, scope);\n\n  // Under the HTMLImports polyfill, scripts in the main document\n  // do not block on imports; we want to allow calls to Polymer in the main\n  // document. Platform collects those calls until we can process them, which\n  // we do here.\n\n  if (Platform.consumeDeclarations) {\n    Platform.consumeDeclarations(function(declarations) {;\n      if (declarations) {\n        for (var i=0, l=declarations.length, d; (i<l) && (d=declarations[i]); i++) {\n          element.apply(null, d);\n        }\n      }\n    });\n  }\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\nvar path = {\n  resolveElementPaths: function(node) {\n    Polymer.urlResolver.resolveDom(node);\n  },\n  addResolvePathApi: function() {\n    // let assetpath attribute modify the resolve path\n    var assetPath = this.getAttribute('assetpath') || '';\n    var root = new URL(assetPath, this.ownerDocument.baseURI);\n    this.prototype.resolvePath = function(urlPath, base) {\n      var u = new URL(urlPath, base || root);\n      return u.href;\n    };\n  }\n};\n\n// exports\nscope.api.declaration.path = path;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n  var api = scope.api.instance.styles;\n  var STYLE_SCOPE_ATTRIBUTE = api.STYLE_SCOPE_ATTRIBUTE;\n\n  var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;\n\n  // magic words\n\n  var STYLE_SELECTOR = 'style';\n  var STYLE_LOADABLE_MATCH = '@import';\n  var SHEET_SELECTOR = 'link[rel=stylesheet]';\n  var STYLE_GLOBAL_SCOPE = 'global';\n  var SCOPE_ATTR = 'polymer-scope';\n\n  var styles = {\n    // returns true if resources are loading\n    loadStyles: function(callback) {\n      var template = this.fetchTemplate();\n      var content = template && this.templateContent();\n      if (content) {\n        this.convertSheetsToStyles(content);\n        var styles = this.findLoadableStyles(content);\n        if (styles.length) {\n          var templateUrl = template.ownerDocument.baseURI;\n          return Polymer.styleResolver.loadStyles(styles, templateUrl, callback);\n        }\n      }\n      if (callback) {\n        callback();\n      }\n    },\n    convertSheetsToStyles: function(root) {\n      var s$ = root.querySelectorAll(SHEET_SELECTOR);\n      for (var i=0, l=s$.length, s, c; (i<l) && (s=s$[i]); i++) {\n        c = createStyleElement(importRuleForSheet(s, this.ownerDocument.baseURI),\n            this.ownerDocument);\n        this.copySheetAttributes(c, s);\n        s.parentNode.replaceChild(c, s);\n      }\n    },\n    copySheetAttributes: function(style, link) {\n      for (var i=0, a$=link.attributes, l=a$.length, a; (a=a$[i]) && i<l; i++) {\n        if (a.name !== 'rel' && a.name !== 'href') {\n          style.setAttribute(a.name, a.value);\n        }\n      }\n    },\n    findLoadableStyles: function(root) {\n      var loadables = [];\n      if (root) {\n        var s$ = root.querySelectorAll(STYLE_SELECTOR);\n        for (var i=0, l=s$.length, s; (i<l) && (s=s$[i]); i++) {\n          if (s.textContent.match(STYLE_LOADABLE_MATCH)) {\n            loadables.push(s);\n          }\n        }\n      }\n      return loadables;\n    },\n    /**\n     * Install external stylesheets loaded in <polymer-element> elements into the \n     * element's template.\n     * @param elementElement The <element> element to style.\n     */\n    installSheets: function() {\n      this.cacheSheets();\n      this.cacheStyles();\n      this.installLocalSheets();\n      this.installGlobalStyles();\n    },\n    /**\n     * Remove all sheets from element and store for later use.\n     */\n    cacheSheets: function() {\n      this.sheets = this.findNodes(SHEET_SELECTOR);\n      this.sheets.forEach(function(s) {\n        if (s.parentNode) {\n          s.parentNode.removeChild(s);\n        }\n      });\n    },\n    cacheStyles: function() {\n      this.styles = this.findNodes(STYLE_SELECTOR + '[' + SCOPE_ATTR + ']');\n      this.styles.forEach(function(s) {\n        if (s.parentNode) {\n          s.parentNode.removeChild(s);\n        }\n      });\n    },\n    /**\n     * Takes external stylesheets loaded in an <element> element and moves\n     * their content into a <style> element inside the <element>'s template.\n     * The sheet is then removed from the <element>. This is done only so \n     * that if the element is loaded in the main document, the sheet does\n     * not become active.\n     * Note, ignores sheets with the attribute 'polymer-scope'.\n     * @param elementElement The <element> element to style.\n     */\n    installLocalSheets: function () {\n      var sheets = this.sheets.filter(function(s) {\n        return !s.hasAttribute(SCOPE_ATTR);\n      });\n      var content = this.templateContent();\n      if (content) {\n        var cssText = '';\n        sheets.forEach(function(sheet) {\n          cssText += cssTextFromSheet(sheet) + '\\n';\n        });\n        if (cssText) {\n          var style = createStyleElement(cssText, this.ownerDocument);\n          content.insertBefore(style, content.firstChild);\n        }\n      }\n    },\n    findNodes: function(selector, matcher) {\n      var nodes = this.querySelectorAll(selector).array();\n      var content = this.templateContent();\n      if (content) {\n        var templateNodes = content.querySelectorAll(selector).array();\n        nodes = nodes.concat(templateNodes);\n      }\n      return matcher ? nodes.filter(matcher) : nodes;\n    },\n    /**\n     * Promotes external stylesheets and <style> elements with the attribute \n     * polymer-scope='global' into global scope.\n     * This is particularly useful for defining @keyframe rules which \n     * currently do not function in scoped or shadow style elements.\n     * (See wkb.ug/72462)\n     * @param elementElement The <element> element to style.\n    */\n    // TODO(sorvell): remove when wkb.ug/72462 is addressed.\n    installGlobalStyles: function() {\n      var style = this.styleForScope(STYLE_GLOBAL_SCOPE);\n      applyStyleToScope(style, document.head);\n    },\n    cssTextForScope: function(scopeDescriptor) {\n      var cssText = '';\n      // handle stylesheets\n      var selector = '[' + SCOPE_ATTR + '=' + scopeDescriptor + ']';\n      var matcher = function(s) {\n        return matchesSelector(s, selector);\n      };\n      var sheets = this.sheets.filter(matcher);\n      sheets.forEach(function(sheet) {\n        cssText += cssTextFromSheet(sheet) + '\\n\\n';\n      });\n      // handle cached style elements\n      var styles = this.styles.filter(matcher);\n      styles.forEach(function(style) {\n        cssText += style.textContent + '\\n\\n';\n      });\n      return cssText;\n    },\n    styleForScope: function(scopeDescriptor) {\n      var cssText = this.cssTextForScope(scopeDescriptor);\n      return this.cssTextToScopeStyle(cssText, scopeDescriptor);\n    },\n    cssTextToScopeStyle: function(cssText, scopeDescriptor) {\n      if (cssText) {\n        var style = createStyleElement(cssText);\n        style.setAttribute(STYLE_SCOPE_ATTRIBUTE, this.getAttribute('name') +\n            '-' + scopeDescriptor);\n        return style;\n      }\n    }\n  };\n\n  function importRuleForSheet(sheet, baseUrl) {\n    var href = new URL(sheet.getAttribute('href'), baseUrl).href;\n    return '@import \\'' + href + '\\';';\n  }\n\n  function applyStyleToScope(style, scope) {\n    if (style) {\n      if (scope === document) {\n        scope = document.head;\n      }\n      if (hasShadowDOMPolyfill) {\n        scope = document.head;\n      }\n      // TODO(sorvell): necessary for IE\n      // see https://connect.microsoft.com/IE/feedback/details/790212/\n      // cloning-a-style-element-and-adding-to-document-produces\n      // -unexpected-result#details\n      // var clone = style.cloneNode(true);\n      var clone = createStyleElement(style.textContent);\n      var attr = style.getAttribute(STYLE_SCOPE_ATTRIBUTE);\n      if (attr) {\n        clone.setAttribute(STYLE_SCOPE_ATTRIBUTE, attr);\n      }\n      // TODO(sorvell): probably too brittle; try to figure out \n      // where to put the element.\n      var refNode = scope.firstElementChild;\n      if (scope === document.head) {\n        var selector = 'style[' + STYLE_SCOPE_ATTRIBUTE + ']';\n        var s$ = document.head.querySelectorAll(selector);\n        if (s$.length) {\n          refNode = s$[s$.length-1].nextElementSibling;\n        }\n      }\n      scope.insertBefore(clone, refNode);\n    }\n  }\n\n  function createStyleElement(cssText, scope) {\n    scope = scope || document;\n    scope = scope.createElement ? scope : scope.ownerDocument;\n    var style = scope.createElement('style');\n    style.textContent = cssText;\n    return style;\n  }\n\n  function cssTextFromSheet(sheet) {\n    return (sheet && sheet.__resource) || '';\n  }\n\n  function matchesSelector(node, inSelector) {\n    if (matches) {\n      return matches.call(node, inSelector);\n    }\n  }\n  var p = HTMLElement.prototype;\n  var matches = p.matches || p.matchesSelector || p.webkitMatchesSelector \n      || p.mozMatchesSelector;\n  \n  // exports\n\n  scope.api.declaration.styles = styles;\n  scope.applyStyleToScope = applyStyleToScope;\n  \n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n  var api = scope.api.instance.events;\n  var EVENT_PREFIX = api.EVENT_PREFIX;\n  // polymer-element declarative api: events feature\n\n  var mixedCaseEventTypes = {};\n  [\n    'webkitAnimationStart',\n    'webkitAnimationEnd',\n    'webkitTransitionEnd',\n    'DOMFocusOut',\n    'DOMFocusIn',\n    'DOMMouseScroll'\n  ].forEach(function(e) {\n    mixedCaseEventTypes[e.toLowerCase()] = e;\n  });\n\n  var events = {\n    parseHostEvents: function() {\n      // our delegates map\n      var delegates = this.prototype.eventDelegates;\n      // extract data from attributes into delegates\n      this.addAttributeDelegates(delegates);\n    },\n    addAttributeDelegates: function(delegates) {\n      // for each attribute\n      for (var i=0, a; a=this.attributes[i]; i++) {\n        // does it have magic marker identifying it as an event delegate?\n        if (this.hasEventPrefix(a.name)) {\n          // if so, add the info to delegates\n          delegates[this.removeEventPrefix(a.name)] = a.value.replace('{{', '')\n              .replace('}}', '').trim();\n        }\n      }\n    },\n    // starts with 'on-'\n    hasEventPrefix: function (n) {\n      return n && (n[0] === 'o') && (n[1] === 'n') && (n[2] === '-');\n    },\n    removeEventPrefix: function(n) {\n      return n.slice(prefixLength);\n    },\n    findController: function(node) {\n      while (node.parentNode) {\n        if (node.eventController) {\n          return node.eventController;\n        }\n        node = node.parentNode;\n      }\n      return node.host;\n    },\n    getEventHandler: function(controller, target, method) {\n      var events = this;\n      return function(e) {\n        if (!controller || !controller.PolymerBase) {\n          controller = events.findController(target);\n        }\n\n        var args = [e, e.detail, e.currentTarget];\n        controller.dispatchMethod(controller, method, args);\n      };\n    },\n    prepareEventBinding: function(pathString, name, node) {\n      if (!this.hasEventPrefix(name))\n        return;\n\n      var eventType = this.removeEventPrefix(name);\n      eventType = mixedCaseEventTypes[eventType] || eventType;\n\n      var events = this;\n\n      return function(model, node, oneTime) {\n        var handler = events.getEventHandler(undefined, node, pathString);\n        PolymerGestures.addEventListener(node, eventType, handler);\n\n        if (oneTime)\n          return;\n\n        // TODO(rafaelw): This is really pointless work. Aside from the cost\n        // of these allocations, NodeBind is going to setAttribute back to its\n        // current value. Fixing this would mean changing the TemplateBinding\n        // binding delegate API.\n        function bindingValue() {\n          return '{{ ' + pathString + ' }}';\n        }\n\n        return {\n          open: bindingValue,\n          discardChanges: bindingValue,\n          close: function() {\n            PolymerGestures.removeEventListener(node, eventType, handler);\n          }\n        };\n      };\n    }\n  };\n\n  var prefixLength = EVENT_PREFIX.length;\n\n  // exports\n  scope.api.declaration.events = events;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // element api\n\n  var properties = {\n    inferObservers: function(prototype) {\n      // called before prototype.observe is chained to inherited object\n      var observe = prototype.observe, property;\n      for (var n in prototype) {\n        if (n.slice(-7) === 'Changed') {\n          if (!observe) {\n            observe  = (prototype.observe = {});\n          }\n          property = n.slice(0, -7)\n          observe[property] = observe[property] || n;\n        }\n      }\n    },\n    explodeObservers: function(prototype) {\n      // called before prototype.observe is chained to inherited object\n      var o = prototype.observe;\n      if (o) {\n        var exploded = {};\n        for (var n in o) {\n          var names = n.split(' ');\n          for (var i=0, ni; ni=names[i]; i++) {\n            exploded[ni] = o[n];\n          }\n        }\n        prototype.observe = exploded;\n      }\n    },\n    optimizePropertyMaps: function(prototype) {\n      if (prototype.observe) {\n        // construct name list\n        var a = prototype._observeNames = [];\n        for (var n in prototype.observe) {\n          var names = n.split(' ');\n          for (var i=0, ni; ni=names[i]; i++) {\n            a.push(ni);\n          }\n        }\n      }\n      if (prototype.publish) {\n        // construct name list\n        var a = prototype._publishNames = [];\n        for (var n in prototype.publish) {\n          a.push(n);\n        }\n      }\n      if (prototype.computed) {\n        // construct name list\n        var a = prototype._computedNames = [];\n        for (var n in prototype.computed) {\n          a.push(n);\n        }\n      }\n    },\n    publishProperties: function(prototype, base) {\n      // if we have any properties to publish\n      var publish = prototype.publish;\n      if (publish) {\n        // transcribe `publish` entries onto own prototype\n        this.requireProperties(publish, prototype, base);\n        // construct map of lower-cased property names\n        prototype._publishLC = this.lowerCaseMap(publish);\n      }\n    },\n    //\n    // `name: value` entries in the `publish` object may need to generate \n    // matching properties on the prototype.\n    //\n    // Values that are objects may have a `reflect` property, which\n    // signals that the value describes property control metadata.\n    // In metadata objects, the prototype default value (if any)\n    // is encoded in the `value` property.\n    //\n    // publish: {\n    //   foo: 5, \n    //   bar: {value: true, reflect: true},\n    //   zot: {}\n    // }\n    //\n    // `reflect` metadata property controls whether changes to the property\n    // are reflected back to the attribute (default false). \n    //\n    // A value is stored on the prototype unless it's === `undefined`,\n    // in which case the base chain is checked for a value.\n    // If the basal value is also undefined, `null` is stored on the prototype.\n    //\n    // The reflection data is stored on another prototype object, `reflect`\n    // which also can be specified directly.\n    //\n    // reflect: {\n    //   foo: true\n    // }\n    //\n    requireProperties: function(propertyInfos, prototype, base) {\n      // per-prototype storage for reflected properties\n      prototype.reflect = prototype.reflect || {};\n      // ensure a prototype value for each property\n      // and update the property's reflect to attribute status\n      for (var n in propertyInfos) {\n        var value = propertyInfos[n];\n        // value has metadata if it has a `reflect` property\n        if (value && value.reflect !== undefined) {\n          prototype.reflect[n] = Boolean(value.reflect);\n          value = value.value;\n        }\n        // only set a value if one is specified\n        if (value !== undefined) {\n          prototype[n] = value;\n        }\n      }\n    },\n    lowerCaseMap: function(properties) {\n      var map = {};\n      for (var n in properties) {\n        map[n.toLowerCase()] = n;\n      }\n      return map;\n    },\n    createPropertyAccessor: function(name) {\n      var proto = this.prototype;\n\n      var privateName = name + '_';\n      var privateObservable  = name + 'Observable_';\n      proto[privateName] = proto[name];\n\n      Object.defineProperty(proto, name, {\n        get: function() {\n          var observable = this[privateObservable];\n          if (observable)\n            observable.deliver();\n\n          return this[privateName];\n        },\n        set: function(value) {\n          var observable = this[privateObservable];\n          if (observable) {\n            observable.setValue(value);\n            return;\n          }\n\n          var oldValue = this[privateName];\n          this[privateName] = value;\n          this.emitPropertyChangeRecord(name, value, oldValue);\n\n          return value;\n        },\n        configurable: true\n      });\n    },\n    createPropertyAccessors: function(prototype) {\n      var n$ = prototype._publishNames;\n      if (n$ && n$.length) {\n        for (var i=0, l=n$.length, n, fn; (i<l) && (n=n$[i]); i++) {\n          this.createPropertyAccessor(n);\n        }\n      }\n      var n$ = prototype._computedNames;\n      if (n$ && n$.length) {\n        for (var i=0, l=n$.length, n, fn; (i<l) && (n=n$[i]); i++) {\n          this.createPropertyAccessor(n);\n        }\n      }\n    }\n  };\n\n  // exports\n\n  scope.api.declaration.properties = properties;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(function(scope) {\n\n  // magic words\n\n  var ATTRIBUTES_ATTRIBUTE = 'attributes';\n  var ATTRIBUTES_REGEX = /\\s|,/;\n\n  // attributes api\n\n  var attributes = {\n    \n    inheritAttributesObjects: function(prototype) {\n      // chain our lower-cased publish map to the inherited version\n      this.inheritObject(prototype, 'publishLC');\n      // chain our instance attributes map to the inherited version\n      this.inheritObject(prototype, '_instanceAttributes');\n    },\n\n    publishAttributes: function(prototype, base) {\n      // merge names from 'attributes' attribute into the 'publish' object\n      var attributes = this.getAttribute(ATTRIBUTES_ATTRIBUTE);\n      if (attributes) {\n        // create a `publish` object if needed.\n        // the `publish` object is only relevant to this prototype, the \n        // publishing logic in `declaration/properties.js` is responsible for\n        // managing property values on the prototype chain.\n        // TODO(sjmiles): the `publish` object is later chained to it's \n        //                ancestor object, presumably this is only for \n        //                reflection or other non-library uses. \n        var publish = prototype.publish || (prototype.publish = {}); \n        // names='a b c' or names='a,b,c'\n        var names = attributes.split(ATTRIBUTES_REGEX);\n        // record each name for publishing\n        for (var i=0, l=names.length, n; i<l; i++) {\n          // remove excess ws\n          n = names[i].trim();\n          // looks weird, but causes n to exist on `publish` if it does not;\n          // a more careful test would need expensive `in` operator\n          if (n && publish[n] === undefined) {\n            publish[n] = undefined;\n          }\n        }\n      }\n    },\n\n    // record clonable attributes from <element>\n    accumulateInstanceAttributes: function() {\n      // inherit instance attributes\n      var clonable = this.prototype._instanceAttributes;\n      // merge attributes from element\n      var a$ = this.attributes;\n      for (var i=0, l=a$.length, a; (i<l) && (a=a$[i]); i++) {  \n        if (this.isInstanceAttribute(a.name)) {\n          clonable[a.name] = a.value;\n        }\n      }\n    },\n\n    isInstanceAttribute: function(name) {\n      return !this.blackList[name] && name.slice(0,3) !== 'on-';\n    },\n\n    // do not clone these attributes onto instances\n    blackList: {\n      name: 1,\n      'extends': 1,\n      constructor: 1,\n      noscript: 1,\n      assetpath: 1,\n      'cache-csstext': 1\n    }\n    \n  };\n\n  // add ATTRIBUTES_ATTRIBUTE to the blacklist\n  attributes.blackList[ATTRIBUTES_ATTRIBUTE] = 1;\n\n  // exports\n\n  scope.api.declaration.attributes = attributes;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // imports\n  var events = scope.api.declaration.events;\n\n  var syntax = new PolymerExpressions();\n  var prepareBinding = syntax.prepareBinding;\n\n  // Polymer takes a first crack at the binding to see if it's a declarative\n  // event handler.\n  syntax.prepareBinding = function(pathString, name, node) {\n    return events.prepareEventBinding(pathString, name, node) ||\n           prepareBinding.call(syntax, pathString, name, node);\n  };\n\n  // declaration api supporting mdv\n  var mdv = {\n    syntax: syntax,\n    fetchTemplate: function() {\n      return this.querySelector('template');\n    },\n    templateContent: function() {\n      var template = this.fetchTemplate();\n      return template && template.content;\n    },\n    installBindingDelegate: function(template) {\n      if (template) {\n        template.bindingDelegate = this.syntax;\n      }\n    }\n  };\n\n  // exports\n  scope.api.declaration.mdv = mdv;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // imports\n  \n  var api = scope.api;\n  var isBase = scope.isBase;\n  var extend = scope.extend;\n\n  var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;\n\n  // prototype api\n\n  var prototype = {\n\n    register: function(name, extendeeName) {\n      // build prototype combining extendee, Polymer base, and named api\n      this.buildPrototype(name, extendeeName);\n      // register our custom element with the platform\n      this.registerPrototype(name, extendeeName);\n      // reference constructor in a global named by 'constructor' attribute\n      this.publishConstructor();\n    },\n\n    buildPrototype: function(name, extendeeName) {\n      // get our custom prototype (before chaining)\n      var extension = scope.getRegisteredPrototype(name);\n      // get basal prototype\n      var base = this.generateBasePrototype(extendeeName);\n      // implement declarative features\n      this.desugarBeforeChaining(extension, base);\n      // join prototypes\n      this.prototype = this.chainPrototypes(extension, base);\n      // more declarative features\n      this.desugarAfterChaining(name, extendeeName);\n    },\n\n    desugarBeforeChaining: function(prototype, base) {\n      // back reference declaration element\n      // TODO(sjmiles): replace `element` with `elementElement` or `declaration`\n      prototype.element = this;\n      // transcribe `attributes` declarations onto own prototype's `publish`\n      this.publishAttributes(prototype, base);\n      // `publish` properties to the prototype and to attribute watch\n      this.publishProperties(prototype, base);\n      // infer observers for `observe` list based on method names\n      this.inferObservers(prototype);\n      // desugar compound observer syntax, e.g. 'a b c' \n      this.explodeObservers(prototype);\n    },\n\n    chainPrototypes: function(prototype, base) {\n      // chain various meta-data objects to inherited versions\n      this.inheritMetaData(prototype, base);\n      // chain custom api to inherited\n      var chained = this.chainObject(prototype, base);\n      // x-platform fixup\n      ensurePrototypeTraversal(chained);\n      return chained;\n    },\n\n    inheritMetaData: function(prototype, base) {\n      // chain observe object to inherited\n      this.inheritObject('observe', prototype, base);\n      // chain publish object to inherited\n      this.inheritObject('publish', prototype, base);\n      // chain reflect object to inherited\n      this.inheritObject('reflect', prototype, base);\n      // chain our lower-cased publish map to the inherited version\n      this.inheritObject('_publishLC', prototype, base);\n      // chain our instance attributes map to the inherited version\n      this.inheritObject('_instanceAttributes', prototype, base);\n      // chain our event delegates map to the inherited version\n      this.inheritObject('eventDelegates', prototype, base);\n    },\n\n    // implement various declarative features\n    desugarAfterChaining: function(name, extendee) {\n      // build side-chained lists to optimize iterations\n      this.optimizePropertyMaps(this.prototype);\n      this.createPropertyAccessors(this.prototype);\n      // install mdv delegate on template\n      this.installBindingDelegate(this.fetchTemplate());\n      // install external stylesheets as if they are inline\n      this.installSheets();\n      // adjust any paths in dom from imports\n      this.resolveElementPaths(this);\n      // compile list of attributes to copy to instances\n      this.accumulateInstanceAttributes();\n      // parse on-* delegates declared on `this` element\n      this.parseHostEvents();\n      //\n      // install a helper method this.resolvePath to aid in \n      // setting resource urls. e.g.\n      // this.$.image.src = this.resolvePath('images/foo.png')\n      this.addResolvePathApi();\n      // under ShadowDOMPolyfill, transforms to approximate missing CSS features\n      if (hasShadowDOMPolyfill) {\n        Platform.ShadowCSS.shimStyling(this.templateContent(), name, extendee);\n      }\n      // allow custom element access to the declarative context\n      if (this.prototype.registerCallback) {\n        this.prototype.registerCallback(this);\n      }\n    },\n\n    // if a named constructor is requested in element, map a reference\n    // to the constructor to the given symbol\n    publishConstructor: function() {\n      var symbol = this.getAttribute('constructor');\n      if (symbol) {\n        window[symbol] = this.ctor;\n      }\n    },\n\n    // build prototype combining extendee, Polymer base, and named api\n    generateBasePrototype: function(extnds) {\n      var prototype = this.findBasePrototype(extnds);\n      if (!prototype) {\n        // create a prototype based on tag-name extension\n        var prototype = HTMLElement.getPrototypeForTag(extnds);\n        // insert base api in inheritance chain (if needed)\n        prototype = this.ensureBaseApi(prototype);\n        // memoize this base\n        memoizedBases[extnds] = prototype;\n      }\n      return prototype;\n    },\n\n    findBasePrototype: function(name) {\n      return memoizedBases[name];\n    },\n\n    // install Polymer instance api into prototype chain, as needed \n    ensureBaseApi: function(prototype) {\n      if (prototype.PolymerBase) {\n        return prototype;\n      }\n      var extended = Object.create(prototype);\n      // we need a unique copy of base api for each base prototype\n      // therefore we 'extend' here instead of simply chaining\n      api.publish(api.instance, extended);\n      // TODO(sjmiles): sharing methods across prototype chains is\n      // not supported by 'super' implementation which optimizes\n      // by memoizing prototype relationships.\n      // Probably we should have a version of 'extend' that is \n      // share-aware: it could study the text of each function,\n      // look for usage of 'super', and wrap those functions in\n      // closures.\n      // As of now, there is only one problematic method, so \n      // we just patch it manually.\n      // To avoid re-entrancy problems, the special super method\n      // installed is called `mixinSuper` and the mixin method\n      // must use this method instead of the default `super`.\n      this.mixinMethod(extended, prototype, api.instance.mdv, 'bind');\n      // return buffed-up prototype\n      return extended;\n    },\n\n    mixinMethod: function(extended, prototype, api, name) {\n      var $super = function(args) {\n        return prototype[name].apply(this, args);\n      };\n      extended[name] = function() {\n        this.mixinSuper = $super;\n        return api[name].apply(this, arguments);\n      }\n    },\n\n    // ensure prototype[name] inherits from a prototype.prototype[name]\n    inheritObject: function(name, prototype, base) {\n      // require an object\n      var source = prototype[name] || {};\n      // chain inherited properties onto a new object\n      prototype[name] = this.chainObject(source, base[name]);\n    },\n\n    // register 'prototype' to custom element 'name', store constructor \n    registerPrototype: function(name, extendee) { \n      var info = {\n        prototype: this.prototype\n      }\n      // native element must be specified in extends\n      var typeExtension = this.findTypeExtension(extendee);\n      if (typeExtension) {\n        info.extends = typeExtension;\n      }\n      // register the prototype with HTMLElement for name lookup\n      HTMLElement.register(name, this.prototype);\n      // register the custom type\n      this.ctor = document.registerElement(name, info);\n    },\n\n    findTypeExtension: function(name) {\n      if (name && name.indexOf('-') < 0) {\n        return name;\n      } else {\n        var p = this.findBasePrototype(name);\n        if (p.element) {\n          return this.findTypeExtension(p.element.extends);\n        }\n      }\n    }\n\n  };\n\n  // memoize base prototypes\n  var memoizedBases = {};\n\n  // implementation of 'chainObject' depends on support for __proto__\n  if (Object.__proto__) {\n    prototype.chainObject = function(object, inherited) {\n      if (object && inherited && object !== inherited) {\n        object.__proto__ = inherited;\n      }\n      return object;\n    }\n  } else {\n    prototype.chainObject = function(object, inherited) {\n      if (object && inherited && object !== inherited) {\n        var chained = Object.create(inherited);\n        object = extend(chained, object);\n      }\n      return object;\n    }\n  }\n\n  // On platforms that do not support __proto__ (versions of IE), the prototype\n  // chain of a custom element is simulated via installation of __proto__.\n  // Although custom elements manages this, we install it here so it's\n  // available during desugaring.\n  function ensurePrototypeTraversal(prototype) {\n    if (!Object.__proto__) {\n      var ancestor = Object.getPrototypeOf(prototype);\n      prototype.__proto__ = ancestor;\n      if (isBase(ancestor)) {\n        ancestor.__proto__ = Object.getPrototypeOf(ancestor);\n      }\n    }\n  }\n\n  // exports\n\n  api.declaration.prototype = prototype;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  /*\n\n    Elements are added to a registration queue so that they register in \n    the proper order at the appropriate time. We do this for a few reasons:\n\n    * to enable elements to load resources (like stylesheets) \n    asynchronously. We need to do this until the platform provides an efficient\n    alternative. One issue is that remote @import stylesheets are \n    re-fetched whenever stamped into a shadowRoot.\n\n    * to ensure elements loaded 'at the same time' (e.g. via some set of\n    imports) are registered as a batch. This allows elements to be enured from\n    upgrade ordering as long as they query the dom tree 1 task after\n    upgrade (aka domReady). This is a performance tradeoff. On the one hand,\n    elements that could register while imports are loading are prevented from \n    doing so. On the other, grouping upgrades into a single task means less\n    incremental work (for example style recalcs),  Also, we can ensure the \n    document is in a known state at the single quantum of time when \n    elements upgrade.\n\n  */\n  var queue = {\n\n    // tell the queue to wait for an element to be ready\n    wait: function(element) {\n      if (!element.__queue) {\n        element.__queue = {};\n        elements.push(element);\n      }\n    },\n\n    // enqueue an element to the next spot in the queue.\n    enqueue: function(element, check, go) {\n      var shouldAdd = element.__queue && !element.__queue.check;\n      if (shouldAdd) {\n        queueForElement(element).push(element);\n        element.__queue.check = check;\n        element.__queue.go = go;\n      }\n      return (this.indexOf(element) !== 0);\n    },\n\n    indexOf: function(element) {\n      var i = queueForElement(element).indexOf(element);\n      if (i >= 0 && document.contains(element)) {\n        i += (HTMLImports.useNative || HTMLImports.ready) ? \n          importQueue.length : 1e9;\n      }\n      return i;  \n    },\n\n    // tell the queue an element is ready to be registered\n    go: function(element) {\n      var readied = this.remove(element);\n      if (readied) {\n        element.__queue.flushable = true;\n        this.addToFlushQueue(readied);\n        this.check();\n      }\n    },\n\n    remove: function(element) {\n      var i = this.indexOf(element);\n      if (i !== 0) {\n        //console.warn('queue order wrong', i);\n        return;\n      }\n      return queueForElement(element).shift();\n    },\n\n    check: function() {\n      // next\n      var element = this.nextElement();\n      if (element) {\n        element.__queue.check.call(element);\n      }\n      if (this.canReady()) {\n        this.ready();\n        return true;\n      }\n    },\n\n    nextElement: function() {\n      return nextQueued();\n    },\n\n    canReady: function() {\n      return !this.waitToReady && this.isEmpty();\n    },\n\n    isEmpty: function() {\n      for (var i=0, l=elements.length, e; (i<l) && \n          (e=elements[i]); i++) {\n        if (e.__queue && !e.__queue.flushable) {\n          return;\n        }\n      }\n      return true;\n    },\n\n    addToFlushQueue: function(element) {\n      flushQueue.push(element);  \n    },\n\n    flush: function() {\n      // prevent re-entrance\n      if (this.flushing) {\n        return;\n      }\n      this.flushing = true;\n      var element;\n      while (flushQueue.length) {\n        element = flushQueue.shift();\n        element.__queue.go.call(element);\n        element.__queue = null;\n      }\n      this.flushing = false;\n    },\n\n    ready: function() {\n      // TODO(sorvell): As an optimization, turn off CE polyfill upgrading\n      // while registering. This way we avoid having to upgrade each document\n      // piecemeal per registration and can instead register all elements\n      // and upgrade once in a batch. Without this optimization, upgrade time\n      // degrades significantly when SD polyfill is used. This is mainly because\n      // querying the document tree for elements is slow under the SD polyfill.\n      var polyfillWasReady = CustomElements.ready;\n      CustomElements.ready = false;\n      this.flush();\n      if (!CustomElements.useNative) {\n        CustomElements.upgradeDocumentTree(document);\n      }\n      CustomElements.ready = polyfillWasReady;\n      Platform.flush();\n      requestAnimationFrame(this.flushReadyCallbacks);\n    },\n\n    addReadyCallback: function(callback) {\n      if (callback) {\n        readyCallbacks.push(callback);\n      }\n    },\n\n    flushReadyCallbacks: function() {\n      if (readyCallbacks) {\n        var fn;\n        while (readyCallbacks.length) {\n          fn = readyCallbacks.shift();\n          fn();\n        }\n      }\n    },\n\n    waitToReady: true\n\n  };\n\n  var elements = [];\n  var flushQueue = [];\n  var importQueue = [];\n  var mainQueue = [];\n  var readyCallbacks = [];\n\n  function queueForElement(element) {\n    return document.contains(element) ? mainQueue : importQueue;\n  }\n\n  function nextQueued() {\n    return importQueue.length ? importQueue[0] : mainQueue[0];\n  }\n\n  function whenReady(callback) {\n    queue.waitToReady = true;\n    HTMLImports.whenImportsReady(function() {\n      queue.addReadyCallback(callback);\n      queue.waitToReady = false;\n      queue.check();\n    });\n  }\n\n  // exports\n  scope.elements = elements;\n  scope.queue = queue;\n  scope.whenReady = scope.whenPolymerReady = whenReady;\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // imports\n\n  var extend = scope.extend;\n  var api = scope.api;\n  var queue = scope.queue;\n  var whenReady = scope.whenReady;\n  var getRegisteredPrototype = scope.getRegisteredPrototype;\n  var waitingForPrototype = scope.waitingForPrototype;\n\n  // declarative implementation: <polymer-element>\n\n  var prototype = extend(Object.create(HTMLElement.prototype), {\n\n    createdCallback: function() {\n      if (this.getAttribute('name')) {\n        this.init();\n      }\n    },\n\n    init: function() {\n      // fetch declared values\n      this.name = this.getAttribute('name');\n      this.extends = this.getAttribute('extends');\n      queue.wait(this);\n      // initiate any async resource fetches\n      this.loadResources();\n      // register when all constraints are met\n      this.registerWhenReady();\n    },\n\n    // TODO(sorvell): we currently queue in the order the prototypes are \n    // registered, but we should queue in the order that polymer-elements\n    // are registered. We are currently blocked from doing this based on \n    // crbug.com/395686.\n    registerWhenReady: function() {\n     if (this.registered\n       || this.waitingForPrototype(this.name)\n       || this.waitingForQueue()\n       || this.waitingForResources()) {\n          return;\n      }\n      queue.go(this);\n    },\n\n    _register: function() {\n      //console.log('registering', this.name);\n      // warn if extending from a custom element not registered via Polymer\n      if (isCustomTag(this.extends) && !isRegistered(this.extends)) {\n        console.warn('%s is attempting to extend %s, an unregistered element ' +\n            'or one that was not registered with Polymer.', this.name,\n            this.extends);\n      }\n      this.register(this.name, this.extends);\n      this.registered = true;\n    },\n\n    waitingForPrototype: function(name) {\n      if (!getRegisteredPrototype(name)) {\n        // then wait for a prototype\n        waitingForPrototype(name, this);\n        // emulate script if user is not supplying one\n        this.handleNoScript(name);\n        // prototype not ready yet\n        return true;\n      }\n    },\n\n    handleNoScript: function(name) {\n      // if explicitly marked as 'noscript'\n      if (this.hasAttribute('noscript') && !this.noscript) {\n        this.noscript = true;\n        // imperative element registration\n        Polymer(name);\n      }\n    },\n\n    waitingForResources: function() {\n      return this._needsResources;\n    },\n\n    // NOTE: Elements must be queued in proper order for inheritance/composition\n    // dependency resolution. Previously this was enforced for inheritance,\n    // and by rule for composition. It's now entirely by rule.\n    waitingForQueue: function() {\n      return queue.enqueue(this, this.registerWhenReady, this._register);\n    },\n\n    loadResources: function() {\n      this._needsResources = true;\n      this.loadStyles(function() {\n        this._needsResources = false;\n        this.registerWhenReady();\n      }.bind(this));\n    }\n\n  });\n\n  // semi-pluggable APIs \n\n  // TODO(sjmiles): should be fully pluggable (aka decoupled, currently\n  // the various plugins are allowed to depend on each other directly)\n  api.publish(api.declaration, prototype);\n\n  // utility and bookkeeping\n\n  function isRegistered(name) {\n    return Boolean(HTMLElement.getPrototypeForTag(name));\n  }\n\n  function isCustomTag(name) {\n    return (name && name.indexOf('-') >= 0);\n  }\n\n  // boot tasks\n\n  whenReady(function() {\n    document.body.removeAttribute('unresolved');\n    document.dispatchEvent(\n      new CustomEvent('polymer-ready', {bubbles: true})\n    );\n  });\n\n  // register polymer-element with document\n\n  document.registerElement('polymer-element', {prototype: prototype});\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  var whenPolymerReady = scope.whenPolymerReady;\n\n  function importElements(elementOrFragment, callback) {\n    if (elementOrFragment) {\n      document.head.appendChild(elementOrFragment);\n      whenPolymerReady(callback);\n    } else if (callback) {\n      callback();\n    }\n  }\n\n  function importUrls(urls, callback) {\n    if (urls && urls.length) {\n        var frag = document.createDocumentFragment();\n        for (var i=0, l=urls.length, url, link; (i<l) && (url=urls[i]); i++) {\n          link = document.createElement('link');\n          link.rel = 'import';\n          link.href = url;\n          frag.appendChild(link);\n        }\n        importElements(frag, callback);\n    } else if (callback) {\n      callback();\n    }\n  }\n\n  // exports\n  scope.import = importUrls;\n  scope.importElements = importElements;\n\n})(Polymer);\n",
    "/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * The `auto-binding` element extends the template element. It provides a quick \n * and easy way to do data binding without the need to setup a model. \n * The `auto-binding` element itself serves as the model and controller for the \n * elements it contains. Both data and event handlers can be bound. \n *\n * The `auto-binding` element acts just like a template that is bound to \n * a model. It stamps its content in the dom adjacent to itself. When the \n * content is stamped, the `template-bound` event is fired.\n *\n * Example:\n *\n *     <template is=\"auto-binding\">\n *       <div>Say something: <input value=\"{{value}}\"></div>\n *       <div>You said: {{value}}</div>\n *       <button on-tap=\"{{buttonTap}}\">Tap me!</button>\n *     </template>\n *     <script>\n *       var template = document.querySelector('template');\n *       template.value = 'something';\n *       template.buttonTap = function() {\n *         console.log('tap!');\n *       };\n *     </script>\n *\n * @module Polymer\n * @status stable\n*/\n\n(function() {\n\n  var element = document.createElement('polymer-element');\n  element.setAttribute('name', 'auto-binding');\n  element.setAttribute('extends', 'template');\n  element.init();\n\n  Polymer('auto-binding', {\n\n    createdCallback: function() {\n      this.syntax = this.bindingDelegate = this.makeSyntax();\n      // delay stamping until polymer-ready so that auto-binding is not\n      // required to load last.\n      Polymer.whenPolymerReady(function() {\n        this.model = this;\n        this.setAttribute('bind', '');\n        // we don't bother with an explicit signal here, we could ust a MO\n        // if necessary\n        this.async(function() {\n          // note: this will marshall *all* the elements in the parentNode\n          // rather than just stamped ones. We'd need to use createInstance\n          // to fix this or something else fancier.\n          this.marshalNodeReferences(this.parentNode);\n          // template stamping is asynchronous so stamping isn't complete\n          // by polymer-ready; fire an event so users can use stamped elements\n          this.fire('template-bound');\n        });\n      }.bind(this));\n    },\n\n    makeSyntax: function() {\n      var events = Object.create(Polymer.api.declaration.events);\n      var self = this;\n      events.findController = function() { return self.model; };\n\n      var syntax = new PolymerExpressions();\n      var prepareBinding = syntax.prepareBinding;  \n      syntax.prepareBinding = function(pathString, name, node) {\n        return events.prepareEventBinding(pathString, name, node) ||\n               prepareBinding.call(syntax, pathString, name, node);\n      };\n      return syntax;\n    }\n\n  });\n\n})();\n"
  ]
}