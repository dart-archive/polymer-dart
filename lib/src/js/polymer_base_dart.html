<!--
Copyright (c) 2015, the Dart project authors.  Please see the AUTHORS file
for details. All rights reserved. Use of this source code is governed by a
BSD-style license that can be found in the LICENSE file.
-->
<script>
  (function() {
    Polymer.Base.originalPolymerCreatedCallback =
        Polymer.Base.createdCallback;
    Polymer.Base.createdCallback = function() {
      if (this.__isPolymerDart__) return;
      this.originalPolymerCreatedCallback();
    };

    Polymer.Dart = {};

    // Placeholder for `undefined` return values. This should eventually go
    // away, once we have dart:js support for `undefined`.
    Polymer.Dart.undefined = {};

    // Used to get an empty constructor function which doesn't call into dart.
    Polymer.Dart.functionFactory = function() { return function() {}; };

    // Generates a function which accesses a particular property on a dart
    // class
    Polymer.Dart.propertyAccessorFactory = function(property, dartGetter) {
      return function() {
        if (this.__cache__) return this.__cache__[property];
        var value = dartGetter(this.__dartClass__);
        if (value === Polymer.Dart.undefined) return undefined;
        return value;
      };
    };

    // Generates a function which sets a particular property on a dart class.
    Polymer.Dart.propertySetterFactory = function(property, dartSetter) {
      return function(value) {
        if (this.__cache__) this.__cache__[property] = value;
        dartSetter(this.__dartClass__, value);
      };
    };

    // Generates a function which invokes a dart function with this or the
    // __dartClass__ proxy if it exists as the first argument, and all other
    // arguments as the second argument.
    Polymer.Dart.invokeDartFactory = function(dartFunction) {
      return function() {
        var thisArg = this.__dartClass__ ? this.__dartClass__ : this;
        // Must convert `arguments` to an actual array that the js side can
        // recognize.
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        var value = dartFunction(thisArg, args);
        if (value === Polymer.Dart.undefined) return undefined;
        return value;
      }
    };

    // Remove any `__dartClass__` instances during serialization.
    Polymer.Dart.serialize = function(value, type) {
      var dartClass = value.__dartClass__;
      delete value.__dartClass__;
      var serialized = Polymer.Base.serialize(value, type);
      value.__dartClass__ = dartClass;
      return serialized;
    };

    // TODO(jakemac): This shouldn't be necessary, but it is today
    // https://github.com/dart-lang/sdk/issues/24371
    Polymer.Dart.deserialize = Polymer.Base.deserialize;

    Polymer.Dart.InteropBehavior = {
      // Secret hook into property changes. Pretty hacky but its more efficient
      // than using a JsProxy object for the element.
      _propertyChanged: function(path, newValue, oldValue) {
        // resolving with keys for array - is it a bug or a feature ?
        var parts = path.split('.');
        var thisArg =  this;
        for (var i=0;i<parts.length-1;i++) {
          if (Array.isArray(thisArg)&&parts[i]==parseInt(parts[i])) {
            thisArg=Polymer.Collection.get(thisArg).getItem(parseInt(parts[i]));
          } else {
            thisArg=thisArg[parts[i]];
          }
        }
        /*
         var thisArg = parts.length == 1 ?
         this : this.get(parts.slice(0, parts.length - 1));*/

        //TODO : should we try to "demangle" the last part of the path too ? (test case : try to replace an element in the collection and see whats happening)
        // but we should revert from keys to array indexes and this is not currently possible.
        //
        thisArg = thisArg.__dartClass__ || thisArg;
        Polymer.Dart.propertyChanged(
                thisArg, parts[parts.length-1], newValue);
      },

      notifyPath: function(path, value, fromAbove) {
        var notified =
            Polymer.Base.notifyPath.call(this, path, value, fromAbove);
        if (fromAbove) return notified;

        // If you call notifyPath from dart we need to do manual modifications
        // on any JsArray or JsObject instances.
        var parts = this._getPathParts(path);
        // if (parts.length > 1) {

        var thisArg =  this;
        for (var i=0;i<parts.length-1;i++) {
          if (Array.isArray(thisArg)&&parts[i]==parseInt(parts[i])) {
            thisArg=Polymer.Collection.get(thisArg).getItem(parseInt(parts[i]));
          } else {
            thisArg=thisArg[parts[i]];
          }
        }
        var last = parts[parts.length-1];
        if (Array.isArray(thisArg)&&last==parseInt(last)) {
          Polymer.Collection.get(thisArg).setItem(parseInt(last),value);
          // WARNING : The following instructon is not right. We should convert from key to index but this isn't possible
          // I added this only to pass the test suite but it is easy to create a new test that will fail,
          // just have to manipulate the list in a way that keys and indexes will not be equals (like on test "List.index")
          // and then try to change an element.
          thisArg[last] = value;
        } else {
          thisArg[last] = value;
        }
        /*
         var model = this.get(parts.splice(0, parts.length - 1));
         if (model[parts[0]] != value) model[parts[0]] = value;
         */
        //}
        return notified;
      },

      serialize: function(value, type) {
        return Polymer.Dart.serialize(value, type);
      }
    }
  })();
</script>
